<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Stream流的最全分类和应用</title><url>https://zhang4014439175.github.io/post/stream%E6%B5%81/</url><categories><category>Java-Base</category></categories><tags><tag>Java</tag><tag>Stream</tag></tags><content type="html">  Java8 中添加了一个新的接口类 Stream，相当于高级版的Iterator，通过Lambda 表达式对集合进行各种非常便利、高效的聚合操作（Aggregate Operation），或者大批量数据操作(Bulk Data Operation）。Stream不仅可以通过串行的方式实现数据操作，还可以通过并行的方式处理大批量数据，提高数据的处理效率。 在《java8 in action》书中，作者说目前我们在几乎所有开发中都会用到集合，但是目前集合在程序开发中的表现还不够完美，比如你利用集合处理大量数据时，你不得不面对性能问题，不得不考虑进行并行代码的编写，这些工作都是比较繁重的，于是作者便创造了Stream 流。
一、Stream流 在Stream流中无法直接修改集合、数组等数据源中的数据，必须重新定义一个来接收结果集。
stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果；
stream不会改变数据源，通常情况下会产生一个新的集合；
stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。
对stream操作分为终端操作和中间操作，那么这两者分别代表什么呢？
终端操作：会消费流，这种操作会产生一个结果的，如果一个流被消费过了，那它就不能被重用的。 中间操作：中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。一个特别需要注意的点是:中间操作不是立即发生的。相反，当在中间操作创建的新流上执行完终端操作后，中间操作指定的操作才会发生。所以中间操作是延迟发生的，中间操作的延迟行为主要是让流API能够更加高效地执行。
stream不可复用，对一个已经进行过终端操作的流再次调用，会抛出异常。
二、函数 1、收集(collect) 归集(toList,toMap,toSet) //tolist List&lt;Integer> result = list.stream.filter(number -> number % 2 == 0).collect(Collector.toList); //tomap Map&lt;String, Integer> map = list.stream().filter( s -> { String[] split = s.split(","); int age = Integer.parseInt(split[1]); return age >= 24; } ).collect(Collector.toMap( s -> s.split(",")[0], (String s) -> { return Integer.parseInt(s.split(",")[1]); } )); //toset List&lt;Integer> list = Arrays.asList(1, 6, 3, 4, 6, 7, 9, 6, 20); List&lt;Integer> listNew = list.stream().filter(x -> x % 2 == 0).collect(Collectors.toList()); Set&lt;Integer> set = list.stream().filter(x -> x % 2 == 0).collect(Collectors.toSet()); 统计(count,averaging) Collectors提供了一系列用于数据统计的静态方法：
计数： count 平均值：averagingInt、averagingLong、averagingDouble 最值： maxBy、minBy 求和： summingInt、summingLong、summingDouble 统计以上所有：summarizingInt、summarizingLong、summarizingDouble
案例：统计员工人数、平均工资、工资总额、最高工资。
List&lt;Person> personList = new ArrayList&lt;Person>(); personList.add(new Person("Tom", 8900, 23, "male", "New York")); personList.add(new Person("Jack", 7000, 25, "male", "Washington")); personList.add(new Person("Lily", 7800, 21, "female", "Washington")); // 求总数 Long count = personList.stream().collect(Collectors.counting()); // 求平均工资 Double average = personList.stream().collect(Collectors.averagingDouble(Person::getSalary)); // 求最高工资 Optional&lt;Integer> max = personList.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compare)); // 求工资之和 Integer sum = personList.stream().collect(Collectors.summingInt(Person::getSalary)); // 一次性统计所有信息 DoubleSummaryStatistics collect = personList.stream().collect(Collectors.summarizingDouble(Person::getSalary)); System.out.println("员工总数：" + count); System.out.println("员工平均工资：" + average); System.out.println("员工工资总和：" + sum); System.out.println("员工工资所有统计：" + collect); 运行结果：
员工总数：3 员工平均工资：7900.0 员工工资总和：23700 员工工资所有统计：DoubleSummaryStatistics{count=3, sum=23700.000000,min=7000.000000, average=7900.000000, max=8900.000000} 分组(partitioningBy/gro..) partitioningBy/groupingBy
分区：将stream按条件分为两个Map，比如员工按薪资是否高于8000分为两部分。 分组：将集合分为多个Map，比如员工按性别分组。有单级分组和多级分组。 List&lt;Person> personList = new ArrayList&lt;Person>(); personList.add(new Person("Tom", 8900, "male", "New York")); personList.add(new Person("Jack", 7000, "male", "Washington")); personList.add(new Person("Lily", 7800, "female", "Washington")); personList.add(new Person("Anni", 8200, "female", "New York")); personList.add(new Person("Owen", 9500, "male", "New York")); personList.add(new Person("Alisa", 7900, "female", "New York")); // 将员工按薪资是否高于8000分组 Map&lt;Boolean, List&lt;Person>> part = personList.stream() .collect(Collectors.partitioningBy(x -> x.getSalary() > 8000)); // 将员工按性别分组 Map&lt;String, List&lt;Person>> group = personList.stream() .collect(Collectors.groupingBy(Person::getSex)); // 将员工先按性别分组，再按地区分组 Map&lt;String, Map&lt;String, List&lt;Person>>> group2 = personList.stream() .collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea))); System.out.println("员工按薪资是否大于8000分组情况：" + part); System.out.println("员工按性别分组情况：" + group); System.out.println("员工按性别、地区：" + group2); 案例二：
//分组数目 System.out.println("分组数目："); Integer groupCount = peopleList .stream() .collect(Collectors .collectingAndThen(Collectors.groupingBy(People::getName), Map::size)); System.out.println(groupCount); System.out.println("-------------------------------------"); //按照名字分组 System.out.println("按照名字分组"); System.out.println(peopleList.stream() .collect(Collectors.groupingBy(People::getName)) ); System.out.println("-------------------------------------"); //按照名字分组(分组的结果是一个map)，并统计每一个分组(map中的每一个value)中的元素数目 System.out.println("统计每一个分组(map中的每一个value)中的元素数目"); System.out.println(peopleList.stream() .collect(Collectors.groupingBy(People::getName, Collectors.counting()))); System.out.println("-------------------------------------"); //按照名字分组(分组的结果是一个map)，并取出每一组的最大值 System.out.println("取出每一组的最大值"); System.out.println(peopleList.stream() .collect(Collectors .groupingBy(People::getName, Collectors.maxBy( new Comparator&lt;People>() { @Override public int compare(People o1, People o2) { return o1.getAge() - o2.getAge(); } })))); //7 //{小猪=[People{age=31, gender=0, name='小猪'},People{age=20, gender=0, name='小猪'},People{age=22, gender=0, name='小猪'}]} //{小猪=2,小龙=3,小白=4,小王=5} //{小猪=Optional[People{age=20, gender=0, name='小猪'}],小龙=Optional[People{age=30, gender=0, name='小龙'}]} 接合(joining) joining可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。
List&lt;Person> personList = new ArrayList&lt;Person>(); personList.add(new Person("Tom", 8900, 23, "male", "New York")); personList.add(new Person("Jack", 7000, 25, "male", "Washington")); personList.add(new Person("Lily", 7800, 21, "female", "Washington")); String names = personList.stream() .map(p -> p.getName()) .collect(Collectors.joining(",")); System.out.println("所有员工的姓名：" + names); List&lt;String> list = Arrays.asList("A", "B", "C"); String string = list.stream() .collect(Collectors.joining("-")); System.out.println("拼接后的字符串：" + string); 运行结果： 所有员工的姓名：Tom,Jack,Lily 拼接后的字符串：A-B-C 归约(reducing) Collectors类提供的reducing方法，相比于stream本身的reduce方法，增加了对自定义归约的支持。
List&lt;Person> personList = new ArrayList&lt;Person>(); personList.add(new Person("Tom", 8900, 23, "male", "New York")); personList.add(new Person("Jack", 7000, 25, "male", "Washington")); personList.add(new Person("Lily", 7800, 21, "female", "Washington")); // 每个员工减去起征点后的薪资之和（这个例子并不严谨，但一时没想到好的例子） Integer sum = personList.stream() .collect(Collectors.reducing(0, Person::getSalary, (i, j) -> (i + j - 5000))); System.out.println("员工扣税薪资总和：" + sum); // stream的reduce Optional&lt;Integer> sum2 = personList.stream() .map(Person::getSalary).reduce(Integer::sum); System.out.println("员工薪资总和：" + sum2.get()); 运行结果： 员工扣税薪资总和：8700 员工薪资总和：23700 2、过滤(filter) List&lt;String>strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl"); // 获取空字符串的数量 long count = strings.stream() .filter(string -> string.isEmpty()) .count(); // filter().limit(2) 案例二： 筛选员工中工资高于8000的人，并形成新的集合。 形成新集合依赖collect（收集），后文有详细介绍。
List&lt;Person> personList = new ArrayList&lt;Person>(); personList.add(new Person("Tom", 8900, 23, "male", "New York")); personList.add(new Person("Jack", 7000, 25, "male", "Washington")); personList.add(new Person("Lily", 7800, 21, "female", "Washington")); personList.add(new Person("Anni", 8200, 24, "female", "New York")); personList.add(new Person("Owen", 9500, 25, "male", "New York")); personList.add(new Person("Alisa", 7900, 26, "female", "New York")); List&lt;String> fiterList = personList.stream() .filter(x -> x.getSalary() > 8000) .map(Person::getName) .collect(Collectors.toList()); System.out.print("高于8000的员工姓名：" + fiterList); 3、归约(reduce) 归约，也称缩减，顾名思义，是把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作。
案例一：求Integer集合的元素之和、乘积和最大值。
List&lt;Integer> list = Arrays.asList(1, 3, 2, 8, 11, 4); // 求和方式1 Optional&lt;Integer> sum = list.stream().reduce((x, y) -> x + y); // 求和方式2 Optional&lt;Integer> sum2 = list.stream().reduce(Integer::sum); // 求和方式3 Integer sum3 = list.stream().reduce(0, Integer::sum); // 求乘积 Optional&lt;Integer> product = list.stream().reduce((x, y) -> x * y); // 求最大值方式1 Optional&lt;Integer> max = list.stream().reduce((x, y) -> x > y ? x : y); // 求最大值写法2 Integer max2 = list.stream().reduce(1, Integer::max); System.out.println("list求和：" + sum.get() + "," + sum2.get() + "," + sum3); System.out.println("list求积：" + product.get()); System.out.println("list求和：" + max.get() + "," + max2); 4、聚合(count,max,min) 过滤出来数据数量合
long count = strings.stream().filter(string -> string.isEmpty()).count(); public class StreamTest { public static void main(String[] args) { List&lt;String> list = Arrays.asList("adnm", "admmt", "pot", "xbangd", "weoujgsd"); Optional&lt;String> max = list.stream().max(Comparator.comparing(String::length)); System.out.println("最长的字符串：" + max.get()); } } 5、遍历匹配(for,find,match) String流的生命周期：同一个流只能遍历一次，遍历完后，这个流就已经被消费掉了。你如果还需要在遍历，可以从原始数据源那里再获得一个新的流来重新遍历一遍。
Random random = new Random(); random.ints().limit(10).forEach(System.out::println); List&lt;Integer> list = Arrays.asList(7, 6, 9, 3, 8, 2, 1); // 遍历输出符合条件的元素 list.stream().filter(x -> x > 6).forEach(System.out::println); // 匹配第一个 Optional&lt;Integer> findFirst = list.stream().filter(x -> x > 6).findFirst(); // 匹配任意（适用于并行流） Optional&lt;Integer> findAny = list.parallelStream().filter(x -> x > 6).findAny(); // 是否包含符合特定条件的元素 boolean anyMatch = list.stream().anyMatch(x -> x > 6); System.out.println("匹配第一个值：" + findFirst.get()); System.out.println("匹配任意一个值：" + findAny.get()); System.out.println("是否存在大于6的值：" + anyMatch); 6、映射(map,faltMap) map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：
map：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。 // 获取对应的平方数 List&lt;Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); List&lt;Integer> squaresList = numbers.stream().map( i -> i*i).distinct().collect(Collectors.toList()); //获取10个姓王的人并输出。 List&lt;Person> personList = fromDB(); // 获得List&lt;Person> personList.stream() .filter(item->item.age == 70) // 过滤条件 .limit(10) // limit限制条件 .filter(item->item.name.startWith("王")) // 过滤条件 .map(item->item.name) // 获得姓名 .forEach(System.out::println); //获取一个String 类型的Stream流 //使用map方法，把字符串类型的整数，转换（映射）为Integer类型的整数 //遍历stream2流 Stream&lt;String> stream = Stream.of("1", "2", "3", "4"); Stream&lt;Integer> stream2 = stream.map(s-> Integer.parseInt(s)); stream2.forEach(i-> System.out.println(i)); 7、提取组合(concat,limit ,sk..) //concat Stream.concat(stream1, stream2).forEach(name ->{ Actor actor = new Actor(name); System.out.println(name) }); //limit Random random = new Random(); random.ints().limit(10).forEach(System.out::println); String[] arr1 = { "a", "b", "c", "d" }; String[] arr2 = { "d", "e", "f", "g" }; Stream&lt;String> stream1 = Stream.of(arr1); Stream&lt;String> stream2 = Stream.of(arr2); // concat:合并两个流 distinct：去重 List&lt;String> newList = Stream.concat(stream1, stream2) .distinct() .collect(Collectors.toList()); // limit：限制从流中获得前n个数据 List&lt;Integer> collect = Stream.iterate(1, x -> x + 2) .limit(10) .collect(Collectors.toList()); // skip：跳过前n个数据 List&lt;Integer> collect2 = Stream.iterate(1, x -> x + 2) .skip(1) .limit(5) .collect(Collectors.toList()); System.out.println("流合并：" + newList); System.out.println("limit：" + collect); System.out.println("skip：" + collect2); 8、排序(Sorted) Random random = new Random(); random.ints().limit(10).sorted().forEach(System.out::println); 9、Collectors Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：
List&lt;String>strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl"); List&lt;String> filtered = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.toList()); System.out.println("筛选列表: " + filtered); //筛选出来的string字符进行拼接 String mergedString = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.joining(", ")); System.out.println("合并字符串: " + mergedString); 三、统计 List&lt;Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); IntSummaryStatistics stats = numbers.stream().mapToInt((x) -> x).summaryStatistics(); System.out.println("列表中最大的数 : " + stats.getMax()); System.out.println("列表中最小的数 : " + stats.getMin()); System.out.println("所有数之和 : " + stats.getSum()); System.out.println("平均数 : " + stats.getAverage()); 四、流创建 1、随机数流 
Random rand = new Random(47); show(rand.ints().boxed()); show(rand.longs().boxed()); show(rand.doubles().boxed()); // 控制上限和下限： show(rand.ints(10, 20).boxed()); show(rand.longs(50, 100).boxed()); show(rand.doubles(20, 30).boxed()); // 控制流大小： show(rand.ints(2).boxed()); show(rand.longs(2).boxed()); show(rand.doubles(2).boxed()); // 控制流的大小和界限 show(rand.ints(3, 3, 9).boxed()); show(rand.longs(3, 12, 22).boxed()); show(rand.doubles(3, 11.5, 12.3).boxed()); 具体看on java 8 第14章，流创建、随机数流 2、int类型的范围 public class Ranges { public static void main(String[] args) { // 传统方法: int result = 0; for (int i = 10; i &lt; 20; i++) result += i; System.out.println(result); // for-in 循环: result = 0; for (int i : range(10, 20).toArray()) result += i; System.out.println(result); // 使用流: System.out.println(range(10, 20).sum()); } }</content></entry><entry><title>String字符串</title><url>https://zhang4014439175.github.io/post/string/</url><categories><category>Java-Base</category></categories><tags><tag>Java</tag><tag>String</tag></tags><content type="html"> String是C++、Java、VB等编程语言中的字符串，字符串是一个特殊的对象，属于引用类型。在Java、C#中，String类对象创建后，字符串一旦初始化就不能更改，因为String类中所有字符串都是常量，数据是无法更改，由于String对象的不可变，所以可以共享。
一、Collectors.joining() 1、拼接字符串 List&lt;String> list = Arrays.asList("Ram","Shyam","Shiv","Mahesh"); String result= list.stream().collect(Collectors.joining()); System.out.println(result); //RamShyamShivMahesh result= list.stream().collect(Collectors.joining(",")); System.out.println(result); //Ram,Shyam,Shiv,Mahesh result= list.stream().collect(Collectors.joining("-","[","]")); System.out.println(result); //[Ram-Shyam-Shiv-Mahesh] 2、拼接对象 package com.concretepage; import java.util.List; import java.util.stream.Collectors; public class JoiningExampleWithListOfObject { public static void main(String[] args) { List&lt;Person> list = new ArrayList&lt;>(); list.add(new Person("Ram", 23)); list.add(new Person("Shyam", 20)); list.add(new Person("Shiv", 25)); list.add(new Person("Mahesh", 30)); String result= list.stream() .map(p -> p.getName()) .collect(Collectors.joining()); System.out.println(result); //RamShyamShivMahesh String result= list.stream() .map(p -> p.getName()) .collect(Collectors.joining("|")); System.out.println(result); //Ram|Shyam|Shiv|Mahesh String result= list.stream().map(p -> p.getName()).collect(Collectors.joining("-","[","]")); System.out.println(result); //[Ram-Shyam-Shiv-Mahesh] String result= list.stream() .map(p -> String.valueOf(p.getAge())) .collect(Collectors.joining()); System.out.println(result); //23202530 String result= list.stream() .map(p -> String.valueOf(p.getAge())) .collect(Collectors.joining("|")); System.out.println(result); //23|20|25|30 String result= list.stream() .map(p -> String.valueOf(p.getAge())) .collect(Collectors.joining("-","[","]")); System.out.println(result); //[23-20-25-30] String result= list.stream() .map(p -> p.getName()+"-" + p.getAge()) .collect(Collectors.joining("|")); System.out.println(result); //Ram-23|Shyam-20|Shiv-25|Mahesh-30 String result= list.stream() .map(p -> p.getName()+"-" + p.getAge()) .collect(Collectors.joining("|","[","]")); System.out.println(result); //[Ram-23|Shyam-20|Shiv-25|Mahesh-30] } } 3、遍历ArrayList中的元素
List&lt;Coffee> coffees = Stream.generate(new CoffeeSupplier()) .limit(10) .collect(Collectors.toList()); System.out.println(coffees); toString() 打印出类的内存地址
@Override public String toString() { //return " InfiniteRecursion address: " + this + "\n" //如果你真的想要打印对象的内存地址，应该调用 Object.toString() 方法，这才是负责此任务的方法。所以，不要使用 this，而是应该调用 super.toString() 方法。 } public static void main(String[] args) { Stream.generate(InfiniteRecursion::new) .limit(10) .forEach(System.out::println); } 二、常见方法 length()
charAt() 获取String中索引位置上的char
getChars()、getBytes() 复制char或byte到一个目标数组中
toCharArray() 生成一个char[]，包含String中的所有字符
equals()、equalsIgnoreCase() 比较两个String的内容是否相同。如果相同，结果为true
compareTo()、compareToIgnoreCase()
​ 按词典顺序比较String的内容，比较结果为负数、零或正数。注意，大小写不等价
contains()
contentEquals() 如果该String对象与参数的内容完全一致，则返回true
isEmpty() 返回boolean结果，以表明String对象的长度是否为0
​ Stringutils.isEmpty() 来判断是否为空null
regionMatches() 返回boolean结果，以表明所比较区域是否相等
startsWith() 返回boolean结果，以表明该String是否以传入参数开始
endsWith() 返回boolean结果，以表明此参数是否是该字符串的后缀
indexOf() 返回在String中的起始索引，如果不包含此参数，就返回-1；
lastIndexOf() lastIndexOf()是从后往前搜索
matches() 返回boolean结果，以表明该String和给出的正则表达式是否匹配
split() 按照正则表达式拆分String，返回一个结果数组
join() 用分隔符拼接字符片段，产生一个新的String
substring() 返回一个新的String对象，以包含参数指定的子串
concat() 拼接字符串
replace() 返回替换字符后的新String对象。如果没有替换发生，则返回原始的String对象
replaceFirst() 返回替换首个目标字符串后的String对象
replaceAll() 返回替换所有目标字符串后的String对象
toLowerCase()
toUpperCase()
trim() 将String两端的空白符删除后，返回一个新的String对象。
​ 如果没有任何改变，则返回原始的String对象
valueOf()
intern() 为每个唯一的字符序列生成一个且仅生成一个String引用。
format() 返回格式化结果String
1、练习 从0 - 100 共25个数字
String result = new Random(47) .ints(25, 0, 100) .mapToObj(Integer::toString) .collect(Collectors.joining(",")); 三、printf() System.out.printf("Row 1: [%d %f]%n", x, y); 这一行代码在运行的时候，首先将 x 的值插入到 %d_ 的位置，然后将 y 的值插入到 %f 的位置。这些占位符叫做格式修饰符，它们不仅指明了插入数据的位置，同时还指明了将会插入什么类型的变量，以及如何格式化。在这个例子中 %d 表示 x 是一个整数，%f 表示 y 是一个浮点数（float 或者 double）。
int x = 5; double y = 5.332542; // The old way: System.out.println("Row 1: [" + x + " " + y + "]"); // The new way: System.out.format("Row 1: [%d %f]%n", x, y); // or System.out.printf("Row 1: [%d %f]%n", x, y); /* Output: Row 1: [5 5.332542] Row 1: [5 5.332542] Row 1: [5 5.332542] */ 格式化修饰符 f.format("%-15s %5s %10s%n", "Item", "Qty", "Price"); f.format("%-15s %5s %10s%n", "----", "---", "-----"); f.format("%-15.15s %5d %10.2f%n", name, qty, price); receiptBuilder.add("Jack's Magic Beans", 4, 4.25); receiptBuilder.add("Princess Peas", 3, 5.1); receiptBuilder.add("Three Bears Porridge", 1, 14.29); total += price * qty; f.format("%-15s %5s %10.2f%n", "Tax", "", total * 0.06); f.format("%-15s %5s %10s%n", "", "", "-----"); f.format("%-15s %5s %10.2f%n", "Total", "", total * 1.06); Formatter转换 下面的表格展示了最常用的类型转换：
类型 含义 d 整型（十进制） c Unicode字符 b Boolean值 s String f 浮点数（十进制） e 浮点数（科学计数） x 整型（十六进制） h 散列码（十六进制） % 字面值“%” 四、正则表达式 System.out.println("-1234".matches("-?\\d+")); System.out.println("5678".matches("-?\\d+")); System.out.println("+911".matches("-?\\d+")); System.out.println("+911".matches("(-|\\+)?\\d+")); /* Output: true true false true */ (-|\+)?
这个正则表达式表示字符串的起始字符可能是一个 - 或 +，或者二者都没有（因为后面跟着 ? 修饰符）。因为字符 + 在正则表达式中有特殊的意义，所以必须使用 \ 将其转义，使之成为表达式中的一个普通字符。
String类还自带了一个非常有用的正则表达式工具——split() 方法，其功能是“将字符串从正则表达式匹配的地方切开。”
public class Splitting { public static String knights = "Then, when you have found the shrubbery, " + "you must cut down the mightiest tree in the " + "forest...with... a herring!"; public static void split(String regex) { System.out.println( Arrays.toString(knights.split(regex))); } public static void main(String[] args) { split(" "); // Doesn't have to contain regex chars split("\\W+"); // Non-word characters split("n\\W+"); // 'n' followed by non-words //按空格来划分字符串。 //一个非单词字符（如果 W 小写，\\w，则表示一个单词字符）。 //表示“字母n后面跟着一个或多个非单词字符。” } } /* Output: [Then,, when, you, have, found, the, shrubbery,, you, must, cut, down, the, mightiest, tree, in, the, forest...with..., a, herring!] [Then, when, you, have, found, the, shrubbery, you, must, cut, down, the, mightiest, tree, in, the, forest, with, a, herring] [The, whe, you have found the shrubbery, you must cut dow, the mightiest tree i, the forest...with... a herring!] */ 用正则表达式进行替换操作时，你可以只替换第一处匹配，也可以替换所有的匹配：
// strings/Replacing.java public class Replacing { static String s = Splitting.knights; public static void main(String[] args) { System.out.println(s.replaceFirst("f\\w+", "located")); //以字母 f 开头，后面跟一个或多个字母（注意这里的 w 是小写的）。并且只替换掉第一个匹配的部分，所以 “found” 被替换成 “located”。 System.out.println(s.replaceAll("shrubbery|tree|herring","banana")); //第二个表达式要匹配的是三个单词中的任意一个，因为它们以竖线分割表示“或”，并且替换所有匹配的部分。 } } /* Output: Then, when you have located the shrubbery, you must cut down the mightiest tree in the forest...with... a herring! Then, when you have found the banana, you must cut down the mightiest banana in the forest...with... a banana! */ 表达式 含义 B 指定字符B \xhh 十六进制值为0xhh的字符 \uhhhh 十六进制表现为0xhhhh的Unicode字符 \t 制表符Tab \n 换行符 \r 回车 \f 换页 \e 转义（Escape） 当你学会了使用字符类（character classes）之后，正则表达式的威力才能真正显现出来。以下是一些创建字符类的典型方式，以及一些预定义的类：
表达式 含义 . 任意字符 [abc] 包含a、b或c的任何字符（和`a [^abc] 除a、b和c之外的任何字符（否定） [a-zA-Z] 从a到z或从A到Z的任何字符（范围） [abc[hij]] a、b、c、h、i、j中的任意字符（与`a [a-z&amp;&amp;[hij]] 任意h、i或j（交） \s 空白符（空格、tab、换行、换页、回车） \S 非空白符（[^\s]） \d 数字（[0-9]） \D 非数字（[^0-9]） \w 词字符（[a-zA-Z_0-9]） \W 非词字符（[^\w]） for(String pattern : new String[]{ "Rudolph", "[rR]udolph", "[rR][aeiou][a-z]ol.*", "R.*" }) System.out.println("Rudolph".matches(pattern)); /* Output: true true true true */ 1、量词 贪婪型： 量词总是贪婪的，除非有其他的选项被设置。贪婪表达式会为所有可能的模式发现尽可能多的匹配。导致此问题的一个典型理由就是假定我们的模式仅能匹配第一个可能的字符组，如果它是贪婪的，那么它就会继续往下匹配。
勉强型： 用问号来指定，这个量词匹配满足模式所需的最少字符数。因此也被称作懒惰的、最少匹配的、非贪婪的或不贪婪的。
占有型： 目前，这种类型的量词只有在 Java 语言中才可用（在其他语言中不可用），并且也更高级，因此我们大概不会立刻用到它。当正则表达式被应用于 String 时，它会产生相当多的状态，以便在匹配失败时可以回溯。而“占有的”量词并不保存这些中间状态，因此它们可以防止回溯。它们常常用于防止正则表达式失控，因此可以使正则表达式执行起来更高效。
贪婪型 勉强型 占有型 如何匹配 X? X?? X?+ 一个或零个X X* X*? X*+ 零个或多个X X+ X+? X++ 一个或多个X X{n} X{n}? X{n}+ 恰好n次X X{n,} X{n,}? X{n,}+ 至少n次X X{n,m} X{n,m}? X{n,m}+ X至少n次，但不超过m次 A(B(C))D
中有三个组：组 0 是 ABCD，组 1 是 BC，组 2 是 C。
Matcher 对象提供了一系列方法，用以获取与组相关的信息：
public int groupCount() 返回该匹配器的模式中的分组数目，组 0 不包括在内。 public String group() 返回前一次匹配操作（例如 find()）的第 0 组（整个匹配）。 public String group(int i) 返回前一次匹配操作期间指定的组号，如果匹配成功，但是指定的组没有匹配输入字符串的任何部分，则将返回 null。 public int start(int group) 返回在前一次匹配操作中寻找到的组的起始索引。 public int end(int group) 返回在前一次匹配操作中寻找到的组的最后一个字符索引加一的值。 2、元字符 元字符：即为有特定含义的字符，常见的元字符如下
代码 说明 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始（在集合字符里[^a]表示非（不匹配）的意思 $ 匹配字符串的结束 详解和示例：
（1）. 匹配任何任意字符 例如 . 可以匹配 1，n，*，+，- ,等
（2）\d\w\s 匹配第一个字符为数字，第二个字符为字母或数字、或下划线或汉字，第三字符为空格的字符串 例如：11 ，2a , 1_
（3）^\d\d\d$ 匹配三个全部都为数字的字符串 例如： 123,456,789
还可以用于验证输入的字符串是否符合qq（身份证号）的验证 ： 例如：^\d{8}$ 匹配8位数字的qq号，^\d{15}&amp;匹配15位均为数字的身份证号 （4）\bOlive\b 匹配单词Olive 例如： I Love Oliver and Olive .这个时候返回的是Olive 而不是Oliver,因为\b&hellip;.\b返回的匹配的单词
3、反义字符 反义字符：多用于查找除某个字符以外其他任意字符均可以的情况
常用的反义字符如下：
代码/语法 说明 \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 详解和示例：
（1）\W 匹配除字母、数字、下划线、汉字以为的字符形如 +，-，*
（2）\S 匹配除空格以外的任意字符形如：1，* ，）
（3）[^abcde]匹配除abcde以为的其他字符 如 e，f，g，h
4、限定字符 限定字符多用于重复匹配次数
常用的限定字符如下
代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 详解和示例：
（1）\d* 匹配重复0次或多次数字 例如:可能为空 或 任意数字 （2,3。。。。）
（2）\d+ 匹配重复1次或多次数字 例如:可能为1个或多个数字 1,23,234,2345，&hellip;&hellip;..
（3）\d? 匹配重复次个或者一次数字 例如：可能为空或者任意的一个数字（1,2，。。。）
（4）\d{8}匹配重复8次数字 例如：123456768
（5）\d{4,}匹配重复至少4次数字 例如：1234,12345,124244,。。。。。
（6）^\d{8,11}$ 匹配重复8-11次数字 例如：12345678,123456789,1234567890,12345678901
5、转义字符 在实际的开发中，可能会遇到要比配元字符的情况，这个时候就需要进行字符转义，如元字符 . * \ 需要转换为. * \
例如： 需要匹配qq邮箱 \d{8,}+qq+.+com 在这里的. 就需要加斜杠
6、字符分枝 字符分枝多用于满足不同情况的选择，用“|”将不同的条件分割开来，比如有些固定电话区号有三位，有些有四位，这个时候可以采用字符分枝
例如：\d{3}-\d{8}|\d{4}-\d{8} 可以匹配两种不同长度区号的固定电话
下边的IP地址正则表达式也有用到字符分枝
7、字符分组 字符分组多用于将多个字符重复，主要通过使用小括号()来进行分组
形如：（\d\w){3} 重复匹配3次（\d\w)
常用于表示IP地址 形如： ((25[0-5]|2[0-4][0-9]|[0-1]\d\d).){3}(25[0-5]|2[0-4][0-9]|[0-1]\d\d)
解析：先把IP地址分为两部分一部分是123.123.123. 另一部分是123，又因Ip最大值为255，所以先使用分组，然后在组里边再进行选择，组里也有三部分，0-199,200-249,250-255，分别和上述的表达是对应，最后还要注意分组之后还要加上一个.，因为是元字符所以要转义故加上. 然后再把这部分整体看做是一个组，重复三次，再加上仅有数字的一组也就是不带.的那一组即可完成IP地址的校验
常用分组语法
分类 代码/语法 说明 (exp) 匹配exp,并捕获文本到自动命名的组里 捕 (?exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?&rsquo;name&rsquo;exp) 获 (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零 (?=exp) 匹配exp前面的位置 宽 (?&lt;=exp) 匹配exp后面的位置 断 (?!exp) 匹配后面跟的不是exp的位置 言 (?&lt;!exp) 匹配前面不是exp的位置 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 8、懒惰匹配和贪婪匹配 贪婪匹配：正则表达式中包含重复的限定符时，通常的行为是匹配尽可能多的字符。
懒惰匹配，有时候需要匹配尽可能少的字符。
例如： a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。但是我们此时可能需要匹配的是ab这样的话就需要用到懒惰匹配了。懒惰匹配会匹配尽可能少的字符
常用的懒惰匹配限定符如下
代码/语法 说明 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 9、后向引用 后向引用用于重复搜索前面某个分组匹配的文本。
使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推
示例：\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。
这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。
你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?\w+)(或者把尖括号换成&rsquo;也行：(?&lsquo;Word&rsquo;\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k,所以上一个例子也可以写成这样：\b(?\w+)\b\s+\k\b
10、零宽断言 有时候需要查找某些匹配之前或之后的东西，这个时候就需要用到们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言
(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如 \b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I&rsquo;m singing while you&rsquo;re dancing.时，它会匹配sing和danc。
(?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。
11、其他语法 12、常用的实用正则表达式整理 只能输入数字："^[0-9]*$"。
　只能输入n位的数字："^&ldquo;d{n}$"。
　只能输入至少n位的数字："^&ldquo;d{n,}$"。
　只能输入m~n位的数字：。"^&ldquo;d{m,n}$&rdquo;
　只能输入零和非零开头的数字："^(0|[1-9][0-9]*)$"。
　只能输入有两位小数的正实数："^[0-9]+(.[0-9]{2})?$"。
　只能输入有1~3位小数的正实数："^[0-9]+(.[0-9]{1,3})?$"。
　只能输入非零的正整数："^"+?[1-9][0-9]*$"。
　只能输入非零的负整数："^&rdquo;-[1-9][]0-9&rdquo;*$。
　只能输入长度为3的字符："^.{3}$"。
　只能输入由26个英文字母组成的字符串："^[A-Za-z]+$"。
　只能输入由26个大写英文字母组成的字符串："^[A-Z]+$"。
　只能输入由26个小写英文字母组成的字符串："^[a-z]+$"。
　只能输入由数字和26个英文字母组成的字符串："^[A-Za-z0-9]+$"。
　只能输入由数字、26个英文字母或者下划线组成的字符串："^&ldquo;w+$"。
　验证用户密码："^[a-zA-Z]&ldquo;w{5,17}$&ldquo;正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。
　验证是否含有^%&amp;’,;=?$&ldquo;&ldquo;等字符：&rdquo;[^%&amp;’,;=?$&ldquo;x22]+"。
　只能输入汉字："^[&ldquo;u4e00-&ldquo;u9fa5]{0,}$&rdquo;
　验证Email地址："^&ldquo;w+([-+.]&ldquo;w+)@&ldquo;w+([-.]&ldquo;w+)&rdquo;.&ldquo;w+([-.]&ldquo;w+)*$"。
　验证InternetURL："^http://([&ldquo;w-]+&rdquo;.)+[&ldquo;w-]+(/[&ldquo;w-./?%&amp;=]*)?$"。
　验证电话号码："^(&rdquo;(&ldquo;d{3,4}-)|&ldquo;d{3.4}-)?&ldquo;d{7,8}$&ldquo;正确格式为：&ldquo;XXX-XXXXXXX&rdquo;、&ldquo;XXXX- XXXXXXXX&rdquo;、&ldquo;XXX-XXXXXXX&rdquo;、&ldquo;XXX-XXXXXXXX&rdquo;、&ldquo;XXXXXXX"和"XXXXXXXX&rdquo;。
　验证身份证号(15位或18位数字)："^&ldquo;d{15}|&ldquo;d{18}$"。
　验证一年的12个月："^(0?[1-9]|1[0-2])$&ldquo;正确格式为：&ldquo;01"～"09"和"1"～"12&rdquo;。
　验证一个月的31天："^((0?[1-9])|((1|2)[0-9])|30|31)$&ldquo;正确格式为;&ldquo;01"～"09"和"1"～"31&rdquo;。</content></entry><entry><title>Java反射机制-内省(IntroSpector)</title><url>https://zhang4014439175.github.io/post/%E5%8F%8D%E5%B0%84-%E5%86%85%E7%9C%81/</url><categories><category>Java-Base</category><category>Spring</category></categories><tags><tag>Java</tag><tag>反射</tag><tag>Spring</tag></tags><content type="html">  开发框架时，经常需要使用java对象的属性来封装程序的数据(其实就是操作对象的set/get方法来设值或取值)，每次都使用反射来完成此类操作过于麻烦，所以JDK里提供了一套API，专门用于操作java对象的属性(set/get方法)。既然内省是专门用于操作java对象属性的，那首先得搞懂什么是对象的属性。
一、java对象的属性 说到属性，大家觉得很熟悉，属性不就是类里最上边的那些全局变量吗？
public class Person { private String name； private int age; } 这种不都是属性吗？其实，这是不对的，刚才说的name、age，准确的来说它们应该称为：“字段”，而不是咱们所说的属性。
Java中的属性是指：设置和读取字段的方法，说白了就是咱们平常见到的set和get方法，只要是set和get开头的方法在java里都认为它是属性(请注意这句话，等下后边会写代码做验证)，属性名称就是set和get方法名称去掉前缀后的内容。
例如：
public void setName(String name) {undefined this.name = name; } 它的属性名称是：name（也就是方法名称”setName”去掉“set”）
当然setName( );和getName( )是指同一个属性 name。
所以，咱们平常说的类里的全局变量，它并不是属性，正确的来说，它应该是字段，只不过咱们平常set和get方法写的名字和字段保持一致，所以导致大家把字段和属性认为是同一个东西。
二、内省的概念和使用 1、内省概念 Introspector 类提供了一种标准方式来了解目标 Java Bean 支持的属性、事件和方法。 Java Bean指的是符合一定规范编写的Java类，具体的规范包括：
属性私有，属性包括普通的类型的属性，EventListener。 提供默认的无参构造函数 私有化的属性可以通过setXxx, getXxx, addXxx, removeXxx, isXxx等类似的方法设置或获得，其中EvenetListener的方法格式为addXxxEventListener, setXxxEventListener。getXxxEventListener,removeXxxEventListener等。 也就意味着我们可以通内省机制获取类的JavaBean的属性，事件和方法。
其实内省就是操作set和get方法的。
那怎么才能得到类中的set和get方法并去操作它呢？通过反射肯定可以，但是在文章开头就已经说了，每次通过反射做的话过于麻烦，所以就出现了下边要讲的内省（Introspector），它就是专门做这个的，它底层也是用反射，只不过给咱们封装了，简化了操作。
public class Student {undefined private String name = "张三";//这是字段 private int age;//这是字段 private Date birthday; public String getName() {//这才是属性，属性指的是设置setter和读取getter字段的方法 return name; } public void setName(String name) {undefined this.name = name; } public int getAge() {undefined return age; } public void setAge(int age) {undefined this.age = age; } public Date getBirthday() {undefined return birthday; } public void setBirthday(Date birthday) {undefined this.birthday = birthday; } //虽然上边的字段里没定义abc这个字段 //但这也是属性：属性名称是abc，注意：只要是set或者get开头的方法都叫属性 public String getAbc(){undefined return "abc"; } } 对上面的对象进行操作，看看有多少个属性。
//内省:操作属性的（类中的getter和setter方法） public class Demo1 {undefined //属性名称：getClass,他的属性名称class //getAbc --->abc @Test public void test1() throws Exception{undefined //得到Student类中的属性，被封装到了BeanInfo中 BeanInfo bi = Introspector.getBeanInfo(Student.class); //得到类中的所有的属性描述器 PropertyDescriptor[] pds = bi.getPropertyDescriptors(); System.out.println("属性的个数："+pds.length); for(PropertyDescriptor pd:pds){undefined System.out.println("属性:"+pd.getName()); } } } 从运行结果上来看，一共得到了5个属性，除了name，age，birthday 外还打印出了abc。
上边的代码验证了：“属性其实是set、get方法”，而并不是类上边的那些字段，不然的话abc不会被打印出来的，但是name，age，birthday再加上abc应该是4个才对，那为什么会打印出5个呢？原因很简单，因为Object类是所有类的父类，Object类里有个方法叫 getClass()。
所以这也验证了咱们刚才说的： “只要是set或者get开头的方法都叫属性”。
2、内省操作 刚才的代码里用到了PropertyDescriptor 这个类，PropertyDescriptor顾名思义，就是属性描述之意。它通过反射 快速操作JavaBean的getter/setter方法。 也就是说它底层也是反射去操作set和get方法，只不过它给咱们封装了，用起来更方便。
PropertyDescriptor中重要的方法：
写方法：getWriteMethod() – 对应set方法，它的返回值是Method对像
读方法：getReadMethod() – 对应get方法，它的返回值是Method对像
//Student s = new Student(); //利用反射生成对象 //com.cj.study.introspector.Student该参数可以配置到配置文件里，这才是我们想要的 //是不是很熟悉？很多框架都是这么做的 Class clazz = Class.forName("com.cj.study.introspector.Student"); Student s = (Student)clazz.newInstance(); PropertyDescriptor pd = new PropertyDescriptor("name", Student.class); Method m = pd.getReadMethod();//得到getName()方法 String value = (String)m.invoke(s, null);//调用getName()方法 System.out.println("调用get方法得到name的值："+value); //改变name的值 Method m1 = pd.getWriteMethod();//得到setName()方法 m1.invoke(s, "李四");//调用setName()方法去修改name的值 System.out.println("调用set方法改变name的值："+s.getName()); 调用get方法得到name的值：张三 调用set方法改变name的值：李四 3、BeanUtils内省操作 操作之前，首先需要导入BeanUtils的jar包，以及它依赖的jar包。
commons-beanutils-1.8.3.jar
commons-logging-1.1.1.jar
导入jar包后，可以看到BeanUtils里有两个重要的方法：
(1).BeanUtils.getProperty(s, &ldquo;name&rdquo;);//调用getName方法
(2).BeanUtils.setProperty(s, &ldquo;name&rdquo;, &ldquo;王五&rdquo;);//调用setName方法
//内省:操作属性的（类中的getter和setter方法） public class Demo1 {undefined //利用BeanUtils框架操作属性:实现原理类似test2 @Test public void test3() throws Exception{undefined Student s = new Student(); //为什么要返回字符串：用户的所有输入都是字符串 String str = BeanUtils.getProperty(s, "name");//调用getName方法 System.out.println(str); //设置值 BeanUtils.setProperty(s, "name", "王五"); System.out.println(s.getName()); } } 张三 王五 4、BeanUtils类型转换的问题 有个问题需要注意：BeanUtils可以进行类型的自动转换，但仅限基本类型。
比如说本来需要int型，给个字符串 “28”，是可以的。
但是仅限基本数据类型，像Date 这种的就不行，会报错，下边用代码体现一下：
//基本数据类型自动转换 @Test public void test4() throws Exception{undefined Student s = new Student(); String str = BeanUtils.getProperty(s, "age"); System.out.println(str); BeanUtils.setProperty(s, "age", "19"); System.out.println(s.getAge()); } //0 //19 //非基本数据类型 @Test public void test5() throws Exception{undefined Student s = new Student(); String str = BeanUtils.getProperty(s, "birthday"); System.out.println(str); BeanUtils.setProperty(s, "birthday", "1989-10-09"); System.out.println(s.getBirthday()); } 发现非基本数据类型值没set进去，而且有错误提示
所以这里涉及到了BeanUtils里的String和其他类型间的互相转换的问题
要想解决这个问题，需要给BeanUtils注册一个类型转换器
代码实现一下
//非基本类型的属性设置 //用户的输入都是String //String &lt;----->其他类型间的互相转换 //用户看到的结果都是String @Test public void test6() throws Exception{undefined Student s = new Student(); //给BeanUtils注册类型转换器：自定义的转换器 ConvertUtils.register(new Converter() {undefined //type:目标类型 //value:当前传入的值 public Object convert(Class type, Object value) {undefined // if(type.equals(Date.class)){undefined // //字符串转换为Date // }else{undefined // //Date转换为字符串 // } DateFormat df = new SimpleDateFormat("yyyy-MM-dd"); if(value instanceof String){undefined //字符串转换为Date String v = (String)value; Date d; try {undefined d = df.parse(v); } catch (ParseException e) {undefined throw new RuntimeException(e); } return d; }else{undefined //Date转换为字符串 Date d = (Date)value; return df.format(d); } } }, Date.class); BeanUtils.setProperty(s, "birthday", "1989-10-09"); System.out.println(s.getBirthday()); } 但是这么手动的去写一个类型转换器，是不是太麻烦了，所以BeanUtils提供了Converter接口很多的实现类
其中有一个DateLocaleConverter类
所以上边的代码可以直接用DateLocaleConverter
@Test//转换器原理参考test6 public void test7() throws Exception{undefined Student s = new Student(); ConvertUtils.register(new DateLocaleConverter(), Date.class); BeanUtils.setProperty(s, "birthday", "1999-10-09"); System.out.println(s.getBirthday()); } 运行结果 发现用了它提供的DateLocaleConverter类后变得很简单，DateLocaleConverter实现的功能就是咱们test6里实现的，它的内部实现，其实和咱们test6里的原理一样。
5、BeanUtils将Map属性自动放到Bean中 package com.cj.study.introspector; import java.util.Date; public class Person {undefined private String name1;//请注意这里我写的是name1，并不是name private int age; private Date birthday; public String getName() {undefined return name1; } public void setName(String name) {//这里的属性写的才是name，进一步验证了属性的定义 this.name1 = name; } public int getAge() {undefined return age; } public void setAge(int age) {undefined this.age = age; } public Date getBirthday() {undefined return birthday; } public void setBirthday(Date birthday) {undefined this.birthday = birthday; } @Override public String toString() {undefined return "Person [age=" + age + ", birthday=" + birthday + ", name1=" \+ name1 + "]"; } } package com.cj.study.introspector; import java.util.Date; import java.util.HashMap; import java.util.Map; import org.apache.commons.beanutils.BeanUtils; import org.apache.commons.beanutils.ConvertUtils; import org.apache.commons.beanutils.locale.converters.DateLocaleConverter; import org.junit.Test; //利用BeanUtils封装数据 public class Demo2 {undefined @Test public void test1() throws Exception{undefined Map map = new HashMap(); //map中的key与属性一致，为了做区分请注意Person类里的字段我写的是name1，进一步验证了对属性的定义 map.put("name", "王小二"); map.put("age", "36"); map.put("birthday", "1979-10-09"); Person p = new Person(); System.out.println("封装数据前："+p); ConvertUtils.register(new DateLocaleConverter(), Date.class); BeanUtils.populate(p, map); System.out.println("封装数据后："+p); } } 运行结果 可以看到值被set进去了
正如大家看到的一样，很多的框架都用到了BeanUtils这个jar包
关于框架中怎么使用BeanUtils，我之前写过一篇手写代码模拟Struts2框架的文章，那里用到了BeanUtils
利用Java反射模拟一个Struts2框架 Struts2主要核心设计 手动实现Struts2核心代码
感兴趣的朋友可以看一下
好了，关于Java的内省，就介绍到这，欢迎大家留言，一起讨论，学习，一起进步</content></entry><entry><title>Java反射机制</title><url>https://zhang4014439175.github.io/post/%E5%8F%8D%E5%B0%84/</url><categories><category>Java-Base</category><category>Spring</category></categories><tags><tag>Java</tag><tag>反射</tag><tag>Spring</tag></tags><content type="html">  JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
 要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.
一、Java中创建对象的方式 java中创建对象大概有这几种方式：
使用new关键字：这是我们最常见的也是最简单的创建对象的方式
使用Clone的方法：无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将前面的对象的内容全部拷贝进去
使用反序列化：当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象
上边是Java中常见的创建对象的三种方式，其实除了上边的三种还有另外一种方式，就是接下来我们要讨论的 “反射”
二、反射概述 1、什么是反射 反射就是把Java类中的各个组成部分进行解剖，并映射成一个个的Java对象，拿到这些对象后可以做一些事情。
既然说反射是解剖Java类中的各个组成部分，所以说咱们得知道一个类中有哪些部分？
例如，一个类有：构造方法，方法，成员变量(字段)，等信息，利用反射技术咱们可以把这些组成部分映射成一个个对象
拿到映射后的构造方法，可以用它来生成对象；拿到映射后的方法，可以调用它来执行对应的方法；拿到映射后的字段，可以用它来获取或改变对应字段的值；
2、反射能干什么 说完反射的概念后，咱们说一下反射能干什么？
一般来说反射是用来做框架的，或者说可以做一些抽象度比较高的底层代码，反射在日常的开发中用到的不多，但是咱们还必须搞懂它，因为搞懂了反射以后，可以帮助咱们理解框架的一些原理。所以说有一句很经典的话：反射是框架设计的灵魂。现在说完这个可能还不太能理解，不急，等下说完一个快速入门的例子后，应该会稍微有点感觉
3、怎么得到想反射的类 刚才已经说过，反射是对一个类进行解剖，想解剖一个东西，前提是首先你得拿到这个东西，那么怎么得到咱们想解剖的类呢？
首先大家要明白一点，咱们写的代码是存储在后缀名是 .java的文件里的，但是它会被编译，最终真正去执行的是编译后的 .class文件。Java是面向对象的语言，一切皆对象，所以java认为 这些编译后的 class文件，这种事物也是一种对象，它也给抽象成了一种类，这个类就是Class。
三、常用方法与应用 1、构造方法 1）获取单个构造方法 Class class = class.forName("com.lizi.pojo.Person"); Person person = new Person(); Class class = Person.class; //反射“一个和多个参数”的构造函数 Constructor c = class.getConstructor(String.class, int.class); c.newInstance("zhangsan",20); //暴力反射私有构造函数 Constructor c = class.getDeclaredConstructor(String.class, int.class); c.setAccessible(true); c.newInstance(20); 2）获取所有的构造方法 Constructor[] cs = class.getDeclaredConstructors(); Constructor[] cs = class.getConstructors()(); for(Constructor c: cs) { sout(c); } 3）获取main方法(同下) //1.获取Class对象 Class stuClass = Class.forName("fanshe.method.Student"); //2.获取所有公有方法 System.out.println("***************获取所有的”公有“方法*******************"); stuClass.getMethods(); Method[] methodArray = stuClass.getMethods(); for(Method m : methodArray){ System.out.println(m); } System.out.println("***************获取所有的方法，包括私有的*******************"); methodArray = stuClass.getDeclaredMethods(); for(Method m : methodArray){ System.out.println(m); } System.out.println("***************获取公有的show1()方法*******************"); Method m = stuClass.getMethod("show1", String.class); System.out.println(m); //实例化一个Student对象 Object obj = stuClass.getConstructor().newInstance(); m.invoke(obj, "刘德华"); System.out.println("***************获取私有的show4()方法******************"); m = stuClass.getDeclaredMethod("show4", int.class); System.out.println(m); m.setAccessible(true);//解除私有限定 Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参 System.out.println("返回值：" + result); 2、方法 批量的：
public Method[] getMethods():获取所有"公有方法"；（包含了父类的方法也包含Object类）
public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)
获取单个的：
public Method getMethod(String name,Class&hellip; parameterTypes):
参数：
name : 方法名；
Class &hellip; : 形参的Class类型对象
public Method getDeclaredMethod(String name,Class&hellip; parameterTypes)
调用方法：
Method &ndash;> public Object invoke(Object obj,Object&hellip; args):
参数说明：
obj : 要调用方法的对象；
args:调用方式时所传递的实参；
1）获取所有的方法 //1.获取Class对象 Class stuClass = Class.forName("fanshe.method.Student"); //2.获取所有公有方法 System.out.println("***************获取所有的”公有“方法*******************"); stuClass.getMethods(); Method[] methodArray = stuClass.getMethods(); for(Method m : methodArray){ System.out.println(m); } System.out.println("***************获取所有的方法，包括私有的*******************"); methodArray = stuClass.getDeclaredMethods(); for(Method m : methodArray){ System.out.println(m); } System.out.println("***************获取公有的show1()方法*******************"); Method m = stuClass.getMethod("show1", String.class); System.out.println(m); //实例化一个Student对象 Object obj = stuClass.getConstructor().newInstance(); m.invoke(obj, "刘德华"); System.out.println("***************获取私有的show4()方法******************"); m = stuClass.getDeclaredMethod("show4", int.class); System.out.println(m); m.setAccessible(true);//解除私有限定 Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参 System.out.println("返回值：" + result); 2）获取单个方法 public void m1() { System.out.println("m1"); } public void m2(String name) { System.out.println(name); } public String m3(String name,int age) { System.out.println(name+":"+age); return "aaa"; } private void m4(Date d) { System.out.println(d); } public static void m5() { System.out.println("m5"); } public static void m6(String[] strs) { System.out.println(strs.length); } public class Demo2 { //获取单个方法 @Test//public void m1() public void test1() throws Exception{ Class clazz = Class.forName("com.cj.test.Person"); Person p = (Person)clazz.newInstance(); Method m = clazz.getMethod("m1", null); m.invoke(p, null); } @Test//public void m2(String name) public void test2() throws Exception{ Class clazz = Person.class; Person p = (Person) clazz.newInstance(); Method m = clazz.getMethod("m2", String.class); m.invoke(p, "张三"); } @Test//public String m3(String name,int age) public void test3() throws Exception{ Class clazz = Person.class; Person p = (Person) clazz.newInstance(); Method m = clazz.getMethod("m3", String.class,int.class); String returnValue = (String)m.invoke(p, "张三",23); System.out.println(returnValue); } @Test//private void m4(Date d) public void test4() throws Exception{ Class clazz = Person.class; Person p = (Person) clazz.newInstance(); Method m = clazz.getDeclaredMethod("m4", Date.class); m.setAccessible(true); m.invoke(p,new Date()); } @Test//public static void m5() public void test5() throws Exception{ Class clazz = Person.class; Method m = clazz.getMethod("m5", null); m.invoke(null,null); } @Test//private static void m6(String[] strs) public void test6() throws Exception{ Class clazz = Person.class; Method m = clazz.getDeclaredMethod("m6",String[].class); m.setAccessible(true); m.invoke(null,(Object)new String[]{"a","b"}); } @Test public void test7() throws Exception{ Class clazz = Person.class; Method m = clazz.getMethod("main",String[].class); m.invoke(null,new Object[]{new String[]{"a","b"}}); } public static void main(String[] args) { System.out.println("main"); } } 注意：看下上边代码里test6和test7的invoke方法里传的参数和其他的有点不一样
这是因为 jdk1.4和jdk1.5处理invoke方法有区别
1.5：public Object invoke(Object obj,Object…args)
1.4：public Object invoke(Object obj,Object[] args)
由于JDK1.4和1.5对invoke方法的处理有区别， 所以在反射类似于main(String[] args) 这种参数是数组的方法时需要特殊处理
启动Java程序的main方法的参数是一个字符串数组，即public static void main(String[] args)，通过反射方式来调用这个main方法时，如何为invoke方法传递参数呢？按jdk1.5的语法，整个数组是一个参数，而按jdk1.4的语法，数组中的每个元素对应一个参数，当把一个字符串数组作为参数传递给invoke方法时，javac会到底按照哪种语法进行处理呢？jdk1.5肯定要兼容jdk1.4的语法，会按jdk1.4的语法进行处理，即把数组打散成为若干个单独的参数。所以，在给main方法传递参数时，不能使用代码mainMethod.invoke(null,new String[]{“xxx”})，javac只把它当作jdk1.4的语法进行理解，而不把它当作jdk1.5的语法解释，因此会出现参数个数不对的问题。
上述问题的解决方法：
（1）mainMethod.invoke(null,new Object[]{new String[]{&ldquo;xxx&rdquo;}});
这种方式，由于你传的是一个数组的参数，所以为了向下兼容1.4的语法，javac遇到数组会给你拆开成多个参数，但是由于咱们这个Object[ ] 数组里只有一个元素值，所以就算它拆也没关系
（2）mainMethod.invoke(null,(Object)new String[]{&ldquo;xxx&rdquo;});
这种方式相当于你传的参数是一个对象，而不是数组，所以就算是按照1.4的语法它也不会拆，所以问题搞定
编译器会作特殊处理，编译时不把参数当作数组看待，也就不会数组打散成若干个参数了
对上边的描述进行一下总结：在反射方法时，如果方法的参数是一个数组，考虑到向下兼容问题，会按照JDK1.4的语法来对待（JVM会把传递的数组参数拆开，拆开就会报参数的个数不匹配的错误） 解决办法：防止JVM拆开你的数组 方式一：把数组看做是一个Object对象 方式二：重新构建一个Object数组，那个参数数组作为唯一的元素存在。
3、属性 1）获取类中的属性字段 获取成员变量并调用：
批量的
1).Field[] getFields():获取所有的"公有字段"
2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；
获取单个的：
1).public Field getField(String fieldName):获取某个"公有的"字段；
2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)
设置字段的值：
Field &ndash;> public void set(Object obj,Object value):
参数说明：
1.obj:要设置的字段所在的对象；
2.value:要为字段设置的值；
//1.获取Class对象 Class stuClass = Class.forName("fanshe.field.Student"); //2.获取字段 System.out.println("************获取所有公有的字段********************"); Field[] fieldArray = stuClass.getFields(); for(Field f : fieldArray){ System.out.println(f); } System.out.println("************获取所有的字段(包括私有、受保护、默认的)********************"); fieldArray = stuClass.getDeclaredFields(); for(Field f : fieldArray){ System.out.println(f); } System.out.println("*************获取公有字段**并调用***********************************"); Field f = stuClass.getField("name"); System.out.println(f); //获取一个对象 Object obj = stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student(); //为字段设置值 f.set(obj, "刘德华");//为Student对象中的name属性赋值--》stu.name = "刘德华" //验证 Student stu = (Student)obj; System.out.println("验证姓名：" + stu.name); System.out.println("**************获取私有字段****并调用********************************"); f = stuClass.getDeclaredField("phoneNum"); System.out.println(f); f.setAccessible(true);//暴力反射，解除私有限定 f.set(obj, "18888889999"); System.out.println("验证电话：" + stu); 2）反射类中的属性字段 public String name="李四"; private int age = 18; public static Date time; @Test public void test1() throws Exception{ Class clazz = Person.class; Person p = (Person)clazz.newInstance(); Field f = clazz.getField("name"); String s = (String)f.get(p); System.out.println(s); //更改name的值 f.set(p, "王六"); System.out.println(p.name); } @Test//private int age = 18; public void test2() throws Exception{ Class clazz = Person.class; Person p = (Person)clazz.newInstance(); Field f = clazz.getDeclaredField("age"); f.setAccessible(true); int age = (Integer)f.get(p); System.out.println(age); f.set(p, 28); age = (Integer)f.get(p); System.out.println(age); } @Test//public static Date time; public void test3() throws Exception{ Class clazz = Person.class; Field f = clazz.getField("time"); f.set(null, new Date()); System.out.println(Person.time); } 以上就是自己对Java中反射的一些学习总结，欢迎大家留言一起学习、讨论。看完上边有关反射的东西， 对常用框架里的配置文件是不是有点思路了。
&lt;context:component-scan base-package="com.fztx"/> &lt;bean id="userService" class="com.fztx.service.UserService"/> 上边是Spring配置文件里的常见的bean配置，这看起来是不是可以用反射很轻易的就可以实现：解析xml然后把xml里的内容作为参数，利用反射创建对象。
拓展：
1、除了上述的Spring配置文件里会用到反射生成bean对象，其他常见的MVC框架，比如Struts2、SpringMVC等等一些框架里还有很多地方都会用到反射。
前端夜页面录入的一些信息通过表单或者其他形式传入后端，后端框架就可以利用反射生成对应的对象，并利用反射操作它的set、get方法把前端传来的信息封装到对象里。
感兴趣的话可以看下这篇：利用Java反射模拟一个Struts2框架 Struts2主要核心设计 手动实现Struts2核心代码，这篇里边包含了XML解析、反射的东西，模拟了一个Struts2的核心代码
2、框架的代码里经常需要利用反射来操作对象的set、get方法，来把程序的数据封装到Java对象中去。
如果每次都使用反射来操作对象的set、get方法进行设置值和取值的话，过于麻烦，所以JDK里提供了一套API，专门用于操作Java对象的属性(set/get方法)，这就是内省
关于内省相关的内容我也整理了一篇文章，感兴趣可以点击：Java反射——内省（Introspector）以及BeanUtils内省框架
3、平常用到的框架，除了配置文件的形式，现在很多都使用了注解的形式。
其实注解也和反射息息相关：使用反射也能轻而易举的拿到类、字段、方法上的注解，然后编写注解解析器对这些注解进行解析，做一些相关的处理
所以说不管是配置文件还是注解的形式，它们都和反射有关。注解和自定义注解的内容，最近也抽时间大概整理了一下，感兴趣的小可爱可以点击了解：Java中的注解以及自定义注解
写在最后：反射是框架的灵魂，具备反射知识和思想，是看懂框架的基础。希望看完文章后对你能有所帮助。
四、其他使用方法 1、通过反射运行配置文件内容 当我们升级这个系统时，不要Student类，而需要新写一个Student2的类时，这时只需要更改pro.txt的文件内容就可以了。代码就一点不用改动
配置文件：
//pro.txt className = cn.fanshe.Student methodName = show 使用案例：
public static void main(String[] args) throws Exception { //通过反射获取Class对象 Class stuClass = Class.forName(getValue("className"));//"cn.fanshe.Student" //2获取show()方法 Method m = stuClass.getMethod(getValue("methodName"));//show //3.调用show()方法 m.invoke(stuClass.getConstructor().newInstance()); } //此方法接收一个key，在配置文件中获取相应的value public static String getValue(String key) throws IOException{ Properties pro = new Properties();//获取配置文件的对象 FileReader in = new FileReader("pro.txt");//获取输入流 pro.load(in);//将流加载到配置文件对象中 in.close(); return pro.getProperty(key);//返回根据key获取的value值 } 2、通过反射越过泛型检查 有一个泛型为String的集合，通过反射向集合中添加一个Integer对象
public static void main(String[] args) throws Exception{ ArrayList&lt;String> strList = new ArrayList&lt;>(); strList.add("aaa"); strList.add("bbb"); // strList.add(100); //获取ArrayList的Class对象，反向的调用add()方法，添加数据 Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象 //获取add()方法 Method m = listClass.getMethod("add", Object.class); //调用add()方法 m.invoke(strList, 100); //遍历集合 for(Object obj : strList){ System.out.println(obj); } 控制台输出： aaa bbb 100 反射就总结到这，下面的内省章节也和反射有关，可以算是反射的高级使用吧，如果有兴趣，可以继续查看总结的内省部分。</content></entry><entry><title>MySql基础入门安装教程</title><url>https://zhang4014439175.github.io/post/mysql%E5%AE%89%E8%A3%85/</url><categories><category>MySql</category></categories><tags><tag>MySql</tag><tag>Sql</tag></tags><content type="html">  MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。
一、MySQL数据库的介绍和安装 1.MySQL数据库介绍 小型的数据库 开源免费(6版本之前免费) 所属于Oracle公司 2.MySQL数据库安装 通过secureCRT工具连接Linux系统
上传 mysql 的安装包
alt + p -------> put d:/setup/mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar 解压 mysql 的安装包 mkdir mysql tar -xvf mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar -C mysql/ 安装客户端 cd mysql/ rpm -ivh mysql-community-client-5.7.27-1.el7.x86_64.rpm --force --nodeps 安装服务端 rpm -ivh mysql-community-server-5.7.27-1.el7.x86_64.rpm --force --nodeps 修改mysql默认字符集 vi /etc/my.cnf 添加如下内容： [mysqld] character-set-server=utf8 collation-server=utf8_general_ci -- 需要在最下方填写 [client] default-character-set=utf8 启动mysql服务 service mysqld start 登录mysql mysql -u root -p 敲回车，输入密码 初始密码查看：cat /var/log/mysqld.log 在root@localhost: 后面的就是初始密码 修改mysql登录密码 set global validate_password_policy=0; set global validate_password_length=1; set password=password('密码'); 授予远程连接权限 //授权 grant all privileges on *.* to 'root' @'%' identified by '密码'; //刷新 flush privileges; 关闭Linux系统防火墙 systemctl stop firewalld.service 3.MySQL数据库登录 sqlyog工具登录mysql</content></entry><entry><title>MySql基础入门（一）</title><url>https://zhang4014439175.github.io/post/mysql%E5%9F%BA%E7%A1%8001/</url><categories><category>MySql</category></categories><tags><tag>MySql</tag><tag>Sql</tag></tags><content type="html">  MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。
一、数据库的基本概念 1.为什么要学数据库？ 之前我们如果想将一些数据实现永久化存储，可以怎么做呢？没错。使用IO流的技术将数据保存到本地文件中 但是接下来我有这样一个需求：将下面的user.txt文件中的王五年龄修改为35 张三 23 男 李四 24 男 王五 25 女 赵六 26 女 周七 27 男 我们要如何实现呢？ 可以采用字符缓冲流，将每一行数据读取出来，封装为User对象。将多个User对象保存到集合中 然后遍历集合，将王五对象的年龄修改为35,再重新将集合中的对象信息写回到文件中 这一套操作太麻烦了，而现在我们有一种更加方便的方式来完成这个需求了，这种方式就是数据库！ 2.什么是数据库？ 用于存储和管理数据的仓库 英文单词为：DataBase，简称DB 3.数据库的好处？ 可以持久化存储数据 方便存储和管理数据 使用了统一的方式操作数据库 &ndash; SQL 4.常见的数据库有哪些？ 二、SQL语句 1.数据库、数据表、数据的关系介绍 数据库 用于存储和管理数据的仓库 一个库中可以包含多个数据表 数据表 数据库最重要的组成部分之一 它由纵向的列和横向的行组成(类似excel表格) 可以指定列名、数据类型、约束等 一个表中可以存储多条数据 数据 想要永久化存储的数据 2.SQL介绍 什么是SQL
Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”。 SQL通用语法
SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 数据库的注释： 单行注释：&ndash; 注释内容 #注释内容(mysql特有) 多行注释：/* 注释内容 */ SQL分类
DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 3.DDL-操作数据库 R(Retrieve)：查询
查询所有数据库 -- 查询所有数据库 SHOWDATABASES; 查询某个数据库的创建语句 -- 标准语法 SHOWCREATEDATABASE数据库名称;-- 查看mysql数据库的创建格式 SHOWCREATEDATABASEmysql; C(Create)：创建
创建数据库 -- 标准语法 CREATEDATABASE数据库名称;-- 创建db1数据库 CREATEDATABASEdb1;-- 创建一个已存在的数据库会报错 -- 错误代码：1007 Can't create database 'db1'; database exists CREATEDATABASEdb1; 创建数据库(判断，如果不存在则创建) -- 标准语法 CREATEDATABASEIFNOTEXISTS数据库名称;-- 创建数据库db2(判断，如果不存在则创建) CREATEDATABASEIFNOTEXISTSdb2; 创建数据库、并指定字符集 -- 标准语法 CREATEDATABASE数据库名称CHARACTERSET字符集名称;-- 创建数据库db3、并指定字符集utf8 CREATEDATABASEdb3CHARACTERSETutf8;-- 查看db3数据库的字符集 SHOWCREATEDATABASEdb3; 练习：创建db4数据库、如果不存在则创建，指定字符集为gbk -- 创建db4数据库、如果不存在则创建，指定字符集为gbk CREATEDATABASEIFNOTEXISTSdb4CHARACTERSETgbk;-- 查看db4数据库的字符集 SHOWCREATEDATABASEdb4; U(Update)：修改
修改数据库的字符集 -- 标准语法 ALTERDATABASE数据库名称CHARACTERSET字符集名称;-- 修改数据库db4的字符集为utf8 ALTERDATABASEdb4CHARACTERSETutf8;-- 查看db4数据库的字符集 SHOWCREATEDATABASEdb4; D(Delete)：删除
删除数据库 -- 标准语法 DROPDATABASE数据库名称;-- 删除db1数据库 DROPDATABASEdb1;-- 删除一个不存在的数据库会报错 -- 错误代码：1008 Can't drop database 'db1'; database doesn't exist DROPDATABASEdb1; 删除数据库(判断，如果存在则删除) -- 标准语法 DROPDATABASEIFEXISTS数据库名称;-- 删除数据库db2，如果存在 DROPDATABASEIFEXISTSdb2; 使用数据库
查询当前正在使用的数据库名称 -- 查询当前正在使用的数据库 SELECTDATABASE(); 使用数据库 -- 标准语法 USE数据库名称；-- 使用db4数据库 USEdb4; 4.DDL-操作数据表 R(Retrieve)：查询
查询数据库中所有的数据表 -- 使用mysql数据库 USEmysql;-- 查询库中所有的表 SHOWTABLES; 查询表结构 -- 标准语法 DESC表名;-- 查询user表结构 DESCuser; 查询表字符集 -- 标准语法 SHOWTABLESTATUSFROM库名LIKE'表名';-- 查看mysql数据库中user表字符集 SHOWTABLESTATUSFROMmysqlLIKE'user'; C(Create)：创建
创建数据表
标准语法 CREATETABLE表名(列名1数据类型1,列名2数据类型2,....列名n数据类型n);-- 注意：最后一列，不需要加逗号 数据类型 1.int：整数类型*ageint2.double:小数类型*scoredouble(5,2)*pricedouble3.date:日期，只包含年月日yyyy-MM-dd4.datetime:日期，包含年月日时分秒yyyy-MM-ddHH:mm:ss5.timestamp:时间戳类型包含年月日时分秒yyyy-MM-ddHH:mm:ss*如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值6.varchar：字符串*namevarchar(20):姓名最大20个字符*zhangsan8个字符张三2个字符 创建数据表 -- 使用db3数据库 USEdb3;-- 创建一个product商品表 CREATETABLEproduct(idINT,-- 商品编号 NAMEVARCHAR(30),-- 商品名称 priceDOUBLE,-- 商品价格 stockINT,-- 商品库存 insert_timeDATE-- 上架时间 ); 复制表 -- 标准语法 CREATETABLE表名LIKE被复制的表名;-- 复制product表到product2表 CREATETABLEproduct2LIKEproduct; U(Update)：修改
修改表名 -- 标准语法 ALTERTABLE表名RENAMETO新的表名;-- 修改product2表名为product3 ALTERTABLEproduct2RENAMETOproduct3; 修改表的字符集 -- 标准语法 ALTERTABLE表名CHARACTERSET字符集名称;-- 查看db3数据库中product3数据表字符集 SHOWTABLESTATUSFROMdb3LIKE'product3';-- 修改product3数据表字符集为gbk ALTERTABLEproduct3CHARACTERSETgbk;-- 查看db3数据库中product3数据表字符集 SHOWTABLESTATUSFROMdb3LIKE'product3'; 添加一列 -- 标准语法 ALTERTABLE表名ADD列名数据类型;-- 给product3表添加一列color ALTERTABLEproduct3ADDcolorVARCHAR(10); 修改列名称和数据类型 -- 修改数据类型 标准语法 ALTERTABLE表名MODIFY列名新数据类型;-- 将color数据类型修改为int ALTERTABLEproduct3MODIFYcolorINT;-- 查看product3表详细信息 DESCproduct3;-- 修改列名和数据类型 标准语法 ALTERTABLE表名CHANGE列名新列名新数据类型;-- 将color修改为address,数据类型为varchar ALTERTABLEproduct3CHANGEcoloraddressVARCHAR(30);-- 查看product3表详细信息 DESCproduct3; 删除列 -- 标准语法 ALTERTABLE表名DROP列名;-- 删除address列 ALTERTABLEproduct3DROPaddress; D(Delete)：删除
删除数据表 -- 标准语法 DROPTABLE表名;-- 删除product3表 DROPTABLEproduct3;-- 删除不存在的表，会报错 -- 错误代码：1051 Unknown table 'product3' DROPTABLEproduct3; 删除数据表(判断，如果存在则删除) -- 标准语法 DROPTABLEIFEXISTS表名;-- 删除product3表，如果存在则删除 DROPTABLEIFEXISTSproduct3; 5.DML-INSERT语句 新增表数据语法
新增格式1：给指定列添加数据 -- 标准语法 INSERTINTO表名(列名1,列名2,...)VALUES(值1,值2,...);-- 向product表添加一条数据 INSERTINTOproduct(id,NAME,price,stock,insert_time)VALUES(1,'手机',1999,22,'2099-09-09');-- 向product表添加指定列数据 INSERTINTOproduct(id,NAME,price)VALUES(2,'电脑',4999);-- 查看表中所有数据 SELECT*FROMproduct; 新增格式2：默认给全部列添加数据 -- 标准语法 INSERTINTO表名VALUES(值1,值2,值3,...);-- 默认给全部列添加数据 INSERTINTOproductVALUES(3,'电视',2999,18,'2099-06-06');-- 查看表中所有数据 SELECT*FROMproduct; 新增格式3：批量添加数据 -- 默认添加所有列数据 标准语法 INSERTINTO表名VALUES(值1,值2,值3,...),(值1,值2,值3,...),(值1,值2,值3,...);-- 批量添加数据 INSERTINTOproductVALUES(4,'冰箱',999,26,'2099-08-08'),(5,'洗衣机',1999,32,'2099-05-10');-- 查看表中所有数据 SELECT*FROMproduct;-- 给指定列添加数据 标准语法 INSERTINTO表名(列名1,列名2,...)VALUES(值1,值2,...),(值1,值2,...),(值1,值2,...);-- 批量添加指定列数据 INSERTINTOproduct(id,NAME,price)VALUES(6,'微波炉',499),(7,'电磁炉',899);-- 查看表中所有数据 SELECT*FROMproduct; 注意事项
列名和值的数量以及数据类型要对应 除了数字类型，其他数据类型的数据都需要加引号(单引双引都可以，推荐单引) 6.DML-UPDATE语句 修改表数据语法 -- 标准语法 UPDATE表名SET列名1=值1,列名2=值2,...[where条件];-- 修改手机的价格为3500 UPDATEproductSETprice=3500WHERENAME='手机';-- 查看所有数据 SELECT*FROMproduct;-- 修改电视的价格为1800、库存为36 UPDATEproductSETprice=1800,stock=36WHERENAME='电视';-- 修改电磁炉的库存为10 UPDATEproductSETstock=10WHEREid=7; 注意事项 修改语句中必须加条件 如果不加条件，则将所有数据都修改 7.DML-DELETE语句 删除表数据语法 -- 标准语法 DELETEFROM表名[WHERE条件];-- 删除product表中的微波炉信息 DELETEFROMproductWHERENAME='微波炉';-- 删除product表中库存为10的商品信息 DELETEFROMproductWHEREstock=10;-- 查看所有商品信息 SELECT*FROMproduct; 注意事项 删除语句中必须加条件 如果不加条件，则将所有数据删除 8.DQL-单表查询 数据准备(直接复制执行即可) -- 创建db1数据库 CREATEDATABASEdb1;-- 使用db1数据库 USEdb1;-- 创建数据表 CREATETABLEproduct(idINT,-- 商品编号 NAMEVARCHAR(20),-- 商品名称 priceDOUBLE,-- 商品价格 brandVARCHAR(10),-- 商品品牌 stockINT,-- 商品库存 insert_timeDATE-- 添加时间 );-- 添加数据 INSERTINTOproductVALUES(1,'华为手机',3999,'华为',23,'2088-03-10'),(2,'小米手机',2999,'小米',30,'2088-05-15'),(3,'苹果手机',5999,'苹果',18,'2088-08-20'),(4,'华为电脑',6999,'华为',14,'2088-06-16'),(5,'小米电脑',4999,'小米',26,'2088-07-08'),(6,'苹果电脑',8999,'苹果',15,'2088-10-25'),(7,'联想电脑',7999,'联想',NULL,'2088-11-11'); 查询语法 select字段列表from表名列表where条件列表groupby分组字段having分组之后的条件orderby排序limit分页限定 查询全部 -- 标准语法 SELECT*FROM表名;-- 查询product表所有数据 SELECT*FROMproduct; 查询部分
多个字段查询 -- 标准语法 SELECT列名1,列名2,...FROM表名;-- 查询名称、价格、品牌 SELECTNAME,price,brandFROMproduct; 去除重复查询 注意：只有全部重复的才可以去除 -- 标准语法 SELECTDISTINCT列名1,列名2,...FROM表名;-- 查询品牌 SELECTbrandFROMproduct;-- 查询品牌，去除重复 SELECTDISTINCTbrandFROMproduct; 计算列的值(四则运算) -- 标准语法 SELECT列名1运算符(+-*/)列名2FROM表名;/* 计算列的值 标准语法： SELECT 列名1 运算符(+ - * /) 列名2 FROM 表名; 如果某一列为null，可以进行替换 ifnull(表达式1,表达式2) 表达式1：想替换的列 表达式2：想替换的值 */-- 查询商品名称和库存，库存数量在原有基础上加10 SELECTNAME,stock+10FROMproduct;-- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断 SELECTNAME,IFNULL(stock,0)+10FROMproduct; 起别名 -- 标准语法 SELECT列名1,列名2,...AS别名FROM表名;-- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断。起别名为getSum SELECTNAME,IFNULL(stock,0)+10ASgetsumFROMproduct;SELECTNAME,IFNULL(stock,0)+10getsumFROMproduct; 条件查询
条件分类 符号 功能 > 大于 &lt; 小于 >= 大于等于 &lt;= 小于等于 = 等于 &lt;> 或 != 不等于 BETWEEN &hellip; AND &hellip; 在某个范围之内(都包含) IN(&hellip;) 多选一 LIKE 占位符 模糊查询 _单个任意字符 %多个任意字符 IS NULL 是NULL IS NOT NULL 不是NULL AND 或 &amp;&amp; 并且 OR 或 || 或者 NOT 或 ! 非，不是 条件查询语法 -- 标准语法 SELECT列名FROM表名WHERE条件;-- 查询库存大于20的商品信息 SELECT*FROMproductWHEREstock>20;-- 查询品牌为华为的商品信息 SELECT*FROMproductWHEREbrand='华为';-- 查询金额在4000 ~ 6000之间的商品信息 SELECT*FROMproductWHEREprice>=4000ANDprice&lt;=6000;SELECT*FROMproductWHEREpriceBETWEEN4000AND6000;-- 查询库存为14、30、23的商品信息 SELECT*FROMproductWHEREstock=14ORstock=30ORstock=23;SELECT*FROMproductWHEREstockIN(14,30,23);-- 查询库存为null的商品信息 SELECT*FROMproductWHEREstockISNULL;-- 查询库存不为null的商品信息 SELECT*FROMproductWHEREstockISNOTNULL;-- 查询名称以小米为开头的商品信息 SELECT*FROMproductWHERENAMELIKE'小米%';-- 查询名称第二个字是为的商品信息 SELECT*FROMproductWHERENAMELIKE'_为%';-- 查询名称为四个字符的商品信息 SELECT*FROMproductWHERENAMELIKE'____';-- 查询名称中包含电脑的商品信息 SELECT*FROMproductWHERENAMELIKE'%电脑%'; 聚合函数
将一列数据作为一个整体，进行纵向的计算 聚合函数分类 函数名 功能 count(列名) 统计数量(一般选用不为null的列) max(列名) 最大值 min(列名) 最小值 sum(列名) 求和 avg(列名) 平均值 聚合函数语法 -- 标准语法 SELECT函数名(列名)FROM表名[WHERE条件];-- 计算product表中总记录条数 SELECTCOUNT(*)FROMproduct;-- 获取最高价格 SELECTMAX(price)FROMproduct;-- 获取最高价格的商品名称 SELECTNAME,priceFROMproductWHEREprice=(SELECTMAX(price)FROMproduct);-- 获取最低库存 SELECTMIN(stock)FROMproduct;-- 获取最低库存的商品名称 SELECTNAME,stockFROMproductWHEREstock=(SELECTMIN(stock)FROMproduct);-- 获取总库存数量 SELECTSUM(stock)FROMproduct;-- 获取品牌为苹果的总库存数量 SELECTSUM(stock)FROMproductWHEREbrand='苹果';-- 获取品牌为小米的平均商品价格 SELECTAVG(price)FROMproductWHEREbrand='小米'; 排序查询
排序分类 注意：多个排序条件，当前边的条件值一样时，才会判断第二条件 关键词 功能 ORDER BY 列名1 排序方式1,列名2 排序方式2 对指定列排序，ASC升序(默认的) DESC降序 排序语法 -- 标准语法 SELECT列名FROM表名[WHERE条件]ORDERBY列名1排序方式1,列名2排序方式2;-- 按照库存升序排序 SELECT*FROMproductORDERBYstockASC;-- 查询名称中包含手机的商品信息。按照金额降序排序 SELECT*FROMproductWHERENAMELIKE'%手机%'ORDERBYpriceDESC;-- 按照金额升序排序，如果金额相同，按照库存降序排列 SELECT*FROMproductORDERBYpriceASC,stockDESC; 分组查询
-- 标准语法 SELECT列名FROM表名[WHERE条件]GROUPBY分组列名[HAVING分组后条件过滤][ORDERBY排序列名排序方式];-- 按照品牌分组，获取每组商品的总金额 SELECTbrand,SUM(price)FROMproductGROUPBYbrand;-- 对金额大于4000元的商品，按照品牌分组,获取每组商品的总金额 SELECTbrand,SUM(price)FROMproductWHEREprice>4000GROUPBYbrand;-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的 SELECTbrand,SUM(price)ASgetSumFROMproductWHEREprice>4000GROUPBYbrandHAVINGgetSum>7000;-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的、并按照总金额的降序排列 SELECTbrand,SUM(price)ASgetSumFROMproductWHEREprice>4000GROUPBYbrandHAVINGgetSum>7000ORDERBYgetSumDESC; 分页查询 -- 标准语法 SELECT列名FROM表名[WHERE条件]GROUPBY分组列名[HAVING分组后条件过滤][ORDERBY排序列名排序方式]LIMIT开始索引,查询条数;-- 公式：开始索引 = (当前页码-1) * 每页显示的条数 -- 每页显示2条数据 SELECT*FROMproductLIMIT0,2;-- 第一页 开始索引=(1-1) * 2 SELECT*FROMproductLIMIT2,2;-- 第二页 开始索引=(2-1) * 2 SELECT*FROMproductLIMIT4,2;-- 第三页 开始索引=(3-1) * 2 SELECT*FROMproductLIMIT6,2;-- 第四页 开始索引=(4-1) * 2 分页查询图解 三、约束 1.约束的概念和分类 约束的概念 对表中的数据进行限定，保证数据的正确性、有效性、完整性！ 约束的分类 约束 说明 PRIMARY KEY 主键约束 PRIMARY KEY AUTO_INCREMENT 主键、自动增长 UNIQUE 唯一约束 NOT NULL 非空约束 FOREIGN KEY 外键约束 FOREIGN KEY ON UPDATE CASCADE 外键级联更新 FOREIGN KEY ON DELETE CASCADE 外键级联删除 2.主键约束 主键约束特点 主键约束包含：非空和唯一两个功能 一张表只能有一个列作为主键 主键一般用于表中数据的唯一标识 建表时添加主键约束 -- 标准语法 CREATETABLE表名(列名数据类型PRIMARYKEY,列名数据类型,...);-- 创建student表 CREATETABLEstudent(idINTPRIMARYKEY-- 给id添加主键约束 );-- 添加数据 INSERTINTOstudentVALUES(1),(2);-- 主键默认唯一，添加重复数据，会报错 INSERTINTOstudentVALUES(2);-- 主键默认非空，不能添加null的数据 INSERTINTOstudentVALUES(NULL);-- 查询student表 SELECT*FROMstudent;-- 查询student表详细 DESCstudent; 删除主键 -- 标准语法 ALTERTABLE表名DROPPRIMARYKEY;-- 删除主键 ALTERTABLEstudentDROPPRIMARYKEY; 建表后单独添加主键 -- 标准语法 ALTERTABLE表名MODIFY列名数据类型PRIMARYKEY;-- 添加主键 ALTERTABLEstudentMODIFYidINTPRIMARYKEY;3.主键自动增长约束 建表时添加主键自增约束 -- 标准语法 CREATETABLE表名(列名数据类型PRIMARYKEYAUTO_INCREMENT,列名数据类型,...);-- 创建student2表 CREATETABLEstudent2(idINTPRIMARYKEYAUTO_INCREMENT-- 给id添加主键自增约束 );-- 添加数据 INSERTINTOstudent2VALUES(1),(2);-- 添加null值，会自动增长 INSERTINTOstudent2VALUES(NULL),(NULL);-- 查询student2表 SELECT*FROMstudent2;-- student2表详细 DESCstudent2; 删除自动增长 -- 标准语法 ALTERTABLE表名MODIFY列名数据类型;-- 删除自动增长 ALTERTABLEstudent2MODIFYidINT; 建表后单独添加自动增长 -- 标准语法 ALTERTABLE表名MODIFY列名数据类型AUTO_INCREMENT;-- 添加自动增长 ALTERTABLEstudent2MODIFYidINTAUTO_INCREMENT;4.唯一约束 建表时添加唯一约束 -- 标准语法 CREATETABLE表名(列名数据类型UNIQUE,列名数据类型,...);-- 创建student3表 CREATETABLEstudent3(idINTPRIMARYKEYAUTO_INCREMENT,telVARCHAR(20)UNIQUE-- 给tel列添加唯一约束 );-- 添加数据 INSERTINTOstudent3VALUES(NULL,'18888888888'),(NULL,'18666666666');-- 添加重复数据，会报错 INSERTINTOstudent3VALUES(NULL,'18666666666');-- 查询student3数据表 SELECT*FROMstudent3;-- student3表详细 DESCstudent3; 删除唯一约束 -- 标准语法 ALTERTABLE表名DROPINDEX列名;-- 删除唯一约束 ALTERTABLEstudent3DROPINDEXtel; 建表后单独添加唯一约束 -- 标准语法 ALTERTABLE表名MODIFY列名数据类型UNIQUE;-- 添加唯一约束 ALTERTABLEstudent3MODIFYtelVARCHAR(20)UNIQUE;5.非空约束 建表时添加非空约束 -- 标准语法 CREATETABLE表名(列名数据类型NOTNULL,列名数据类型,...);-- 创建student4表 CREATETABLEstudent4(idINTPRIMARYKEYAUTO_INCREMENT,NAMEVARCHAR(20)NOTNULL-- 给name添加非空约束 );-- 添加数据 INSERTINTOstudent4VALUES(NULL,'张三'),(NULL,'李四');-- 添加null值，会报错 INSERTINTOstudent4VALUES(NULL,NULL); 删除非空约束 -- 标准语法 ALTERTABLE表名MODIFY列名数据类型;-- 删除非空约束 ALTERTABLEstudent4MODIFYNAMEVARCHAR(20); 建表后单独添加非空约束
-- 标准语法 ALTERTABLE表名MODIFY列名数据类型NOTNULL;-- 添加非空约束 ALTERTABLEstudent4MODIFYNAMEVARCHAR(20)NOTNULL;</content></entry><entry><title>关于我</title><url>https://zhang4014439175.github.io/about.html</url><categories/><tags/><content type="html"> 我叫张志明，英文名zhang zhiming。 职业：后端攻城师 —— 一个90后程序员，终身学习者。 评价：对技术充满热情，充满学习的动力。—— 只要投入时间去学，没有学不会的东西。 技能：主职业是后端（Java、Python）、运维、大数据的技术栈也有所涉及。 业余：业余时间学习过设计的知识，如果逮住合适的机会，也会培养全方位的技能。 娱乐：爱阅读，但读不进文学名著；军事政治爱好者，跑步锻炼忠实粉丝；喜欢 MMORPG 游戏，但现阶段还是要以赚钱为主，等退休了再玩个痛快。 心态：爱生活、爱阅读、爱学习、爱拼搏、爱大自然。 原则：常怀感恩的心。 社交：一个人走得快，一群人走得远。 理财：人生就像滚雪球，重要的是，找到那条又湿又长的雪道。
一、心路历程 小学时候喜欢玩电脑，刚开始没有电脑的时候喜欢往别人家跑，老妈为了把我拴住于是买了第一台电脑。家里一台电脑经受了我的好多锤炼，主机、宽带处理问题都是自己搞。
高中时候自学很多软件，但是没有专研下去。
上大学前学习艺术，于是填志愿去了视觉传达设计（保底也能去打印店作业）。但是对计算机有浓厚的兴趣，因此利用课余时间自学 Java 技术栈。
大三实习期间走出校门，转型到了 IT 行业。在老家山西干了一年Java，开始主做前端。前端能及时给出视觉反馈的特点，成了我热衷这个岗位的最大原因。
有着去大厂的梦想，不过条条大路通罗马，大厂是一条路但不是唯一的路，因而充实好自己最重要，有机会就努力抓住机会，没有机会就自己创造机会。
我是一个普通的程序员，一个平凡的 90 后，但我不想让自己的人生平庸，奥力给！
更多信息请访问我的博客。</content></entry><entry><title>Markdown语法手册</title><url>https://zhang4014439175.github.io/post/markdown-syntax/</url><categories><category>themes</category><category>syntax</category></categories><tags><tag>markdown</tag><tag>css</tag><tag>html</tag></tags><content type="html"> 本文提供了一个可以在 Hugo 内容文件中使用的基本Markdown语法示例，还展示了基本 HTML 元素在 Hugo 主题中是否使用 CSS 装饰。
标题 下面的 HTML 代码&lt;h1>—&lt;h6> 元素表示六个级别的节标题。 &lt;h1>是最高的节级别，&lt;h6>是最低的节级别。
H1 H2 H3 H4 H5 H6 段落 Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.
伊塔图？厨房里有很多东西，我不知道他们喜欢吃什么，或者他们喜欢吃什么。
引用 blockquote元素表示从另一个来源引用的内容，可选的引用必须在footer或cite元素内，也可选的内嵌更改，如注释和缩写。
引用没有归属 Tiam, ad mint andaepu dandae nostion secatur sequo quae. 注意 可以在块引用中使用 Markdown 语法。
带归属的引用 不要通过分享记忆来交流，通过交流来分享记忆。
— 罗布·派克1
表格 表不是Markdown核心规范的一部分，但是Hugo支持开箱即用。
Name Age Bob 27 Alice 23 表格内使用Markdown语法 Italics Bold Code italics bold code 图像 ![图像描述](图像地址) 示例 Google Chrome Firefox Browser
点击图像可以打开图像浏览器，快试试吧。
代码块 带有引号的代码块 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 用四个空格缩进的代码块 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 代码块引用Hugo的内部高亮短代码 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 列表类型 有序列表 First item Second item Third item 无序列表 List item Another item And another item 嵌套列表 Fruit Apple Orange Banana Dairy Milk Cheese 其他元素 — abbr, sub, sup, kbd, mark GIF 是位图图像格式。
H2O
Xn + Yn = Zn
按 CTRL+ALT+Delete 组合键结束会话。
大多数蝾螈在夜间活动，捕食昆虫、蠕虫和其他小动物。
以上引文摘自Rob Pike在2015年11月18日Gopherfest上的演讲。&#160;&#8617;&#xfe0e;</content></entry><entry><title>占位符文本显示</title><url>https://zhang4014439175.github.io/post/placeholder-text/</url><categories/><tags><tag>markdown</tag><tag>text</tag></tags><content type="html"> 你对我的心有偏见。我向您保证，我们的生活将不会受到影响，我们的生活将会受到影响。你说你现在住在医院里，因为你的眼睛是透明的，你的眼睛是光明的，你的眼睛是光明的!
Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.
Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt
The Van de Graaf Canon
Mane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.
Iubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.
Eurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.</content></entry><entry><title>数据公式设置显示</title><url>https://zhang4014439175.github.io/post/math-typesetting/</url><categories/><tags/><content type="html"> Hugo项目中的数学表示法可以通过使用第三方JavaScript库来实现。
在这个例子中，我们将使用 MathJax
Create a post under /content/en[zh-CN]/math.md
可以全局启用MathJax，请在项目配置中将参数math设置为true
或是在每页基础上启用MathJax，在内容文件中包括参数math: true
注意： 使用支持的TeX功能的联机参考资料
例子 重复的分数 $$ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} \equiv 1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}} {1+\frac{e^{-8\pi}} {1+\cdots} } } } $$
总和记号 $$ \left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right) $$
几何级数之和 我把接下来的两个例子分成了几行，这样它在手机上表现得更好。这就是为什么它们包含 \displaystyle。
$$ \displaystyle\sum_{i=1}^{k+1}i $$
$$ \displaystyle= \left(\sum_{i=1}^{k}i\right) +(k+1) $$
$$ \displaystyle= \frac{k(k+1)}{2}+k+1 $$
$$ \displaystyle= \frac{k(k+1)+2(k+1)}{2} $$
$$ \displaystyle= \frac{(k+1)(k+2)}{2} $$
$$ \displaystyle= \frac{(k+1)((k+1)+1)}{2} $$
乘记号 $$ \displaystyle 1 + \frac{q^2}{(1-q)}+\frac{q^6}{(1-q)(1-q^2)}+\cdots = \displaystyle \prod_{j=0}^{\infty}\frac{1}{(1-q^{5j+2})(1-q^{5j+3})}, \displaystyle\text{ for }\lvert q\rvert &lt; 1. $$
随文数式 这是一些线性数学: $$ k_{n+1} = n^2 + k_n^2 - k_{n-1} $$ ， 然后是更多的文本。
希腊字母 $$ \Gamma\ \Delta\ \Theta\ \Lambda\ \Xi\ \Pi\ \Sigma\ \Upsilon\ \Phi\ \Psi\ \Omega \alpha\ \beta\ \gamma\ \delta\ \epsilon\ \zeta\ \eta\ \theta\ \iota\ \kappa\ \lambda\ \mu\ \nu\ \xi \ \omicron\ \pi\ \rho\ \sigma\ \tau\ \upsilon\ \phi\ \chi\ \psi\ \omega\ \varepsilon\ \vartheta\ \varpi\ \varrho\ \varsigma\ \varphi $$
箭头 $$ \gets\ \to\ \leftarrow\ \rightarrow\ \uparrow\ \Uparrow\ \downarrow\ \Downarrow\ \updownarrow\ \Updownarrow $$
$$ \Leftarrow\ \Rightarrow\ \leftrightarrow\ \Leftrightarrow\ \mapsto\ \hookleftarrow \leftharpoonup\ \leftharpoondown\ \rightleftharpoons\ \longleftarrow\ \Longleftarrow\ \longrightarrow $$
$$ \Longrightarrow\ \longleftrightarrow\ \Longleftrightarrow\ \longmapsto\ \hookrightarrow\ \rightharpoonup $$
$$ \rightharpoondown\ \leadsto\ \nearrow\ \searrow\ \swarrow\ \nwarrow $$
符号 $$ \surd\ \barwedge\ \veebar\ \odot\ \oplus\ \otimes\ \oslash\ \circledcirc\ \boxdot\ \bigtriangleup $$
$$ \bigtriangledown\ \dagger\ \diamond\ \star\ \triangleleft\ \triangleright\ \angle\ \infty\ \prime\ \triangle $$
微积分学 $$ \int u \frac{dv}{dx},dx=uv-\int \frac{du}{dx}v,dx $$
$$ f(x) = \int_{-\infty}^\infty \hat f(\xi),e^{2 \pi i \xi x} $$
$$ \oint \vec{F} \cdot d\vec{s}=0 $$
洛伦茨方程 $$ \begin{aligned} \dot{x} &amp; = \sigma(y-x) \ \dot{y} &amp; = \rho x - y - xz \ \dot{z} &amp; = -\beta z + xy \end{aligned} $$
交叉乘积 这在KaTeX中是可行的，但在这种环境中馏分的分离不是很好。
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
这里有一个解决方案:使用“mfrac”类(在MathJax情况下没有区别)的额外类使分数更小:
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
强调 $$ \hat{x}\ \vec{x}\ \ddot{x} $$
有弹性的括号 $$ \left(\frac{x^2}{y^3}\right) $$
评估范围 $$ \left.\frac{x^3}{3}\right|_0^1 $$
诊断标准 $$ f(n) = \begin{cases} \frac{n}{2}, &amp; \text{if } n\text{ is even} \ 3n+1, &amp; \text{if } n\text{ is odd} \end{cases} $$
麦克斯韦方程组 $$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \ \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \ \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \ \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
这些方程式很狭窄。我们可以使用(例如)添加垂直间距 [1em] 在每个换行符(\)之后。正如你在这里看到的：
$$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \[1em] \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \[0.5em] \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \[1em] \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
统计学 固定词组：
$$ \frac{n!}{k!(n-k)!} = {^n}C_k {n \choose k} $$
分数在分数 $$ \frac{\frac{1}{x}+\frac{1}{y}}{y-z} $$
ｎ次方根 $$ \sqrt[n]{1+x+x^2+x^3+\ldots} $$
矩阵 $$ \begin{pmatrix} a_{11} &amp; a_{12} &amp; a_{13}\ a_{21} &amp; a_{22} &amp; a_{23}\ a_{31} &amp; a_{32} &amp; a_{33} \end{pmatrix} \begin{bmatrix} 0 &amp; \cdots &amp; 0 \ \vdots &amp; \ddots &amp; \vdots \ 0 &amp; \cdots &amp; 0 \end{bmatrix} $$
标点符号 $$ f(x) = \sqrt{1+x} \quad (x \ge -1) f(x) \sim x^2 \quad (x\to\infty) $$
现在用标点符号:
$$ f(x) = \sqrt{1+x}, \quad x \ge -1 f(x) \sim x^2, \quad x\to\infty $$</content></entry><entry><title>支持Emoji表情符号</title><url>https://zhang4014439175.github.io/post/emoji-support/</url><categories/><tags><tag>emoji</tag></tags><content type="html"> 在Hugo项目中可以通过多种方式启用Emoji。
The emojify function can be called directly in templates or Inline Shortcodes.
To enable emoji globally, set enableEmoji to true in your site&rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.
馃檲 🙈 馃檳 🙉 馃檴 🙊
The Emoji cheat sheet is a useful reference for emoji shorthand codes.
N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.
.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }</content></entry></search>