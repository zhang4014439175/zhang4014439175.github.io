<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Stream流的最全分类和应用</title><url>https://zhang4014439175.github.io/post/stream%E6%B5%81/</url><categories><category>Java-Base</category></categories><tags><tag>Java</tag><tag>Stream</tag></tags><content type="html">  Java8 中添加了一个新的接口类 Stream，相当于高级版的Iterator，通过Lambda 表达式对集合进行各种非常便利、高效的聚合操作（Aggregate Operation），或者大批量数据操作(Bulk Data Operation）。Stream不仅可以通过串行的方式实现数据操作，还可以通过并行的方式处理大批量数据，提高数据的处理效率。 在《java8 in action》书中，作者说目前我们在几乎所有开发中都会用到集合，但是目前集合在程序开发中的表现还不够完美，比如你利用集合处理大量数据时，你不得不面对性能问题，不得不考虑进行并行代码的编写，这些工作都是比较繁重的，于是作者便创造了Stream 流。
一、Stream流 在Stream流中无法直接修改集合、数组等数据源中的数据，必须重新定义一个来接收结果集。
stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果；
stream不会改变数据源，通常情况下会产生一个新的集合；
stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。
对stream操作分为终端操作和中间操作，那么这两者分别代表什么呢？
终端操作：会消费流，这种操作会产生一个结果的，如果一个流被消费过了，那它就不能被重用的。 中间操作：中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。一个特别需要注意的点是:中间操作不是立即发生的。相反，当在中间操作创建的新流上执行完终端操作后，中间操作指定的操作才会发生。所以中间操作是延迟发生的，中间操作的延迟行为主要是让流API能够更加高效地执行。
stream不可复用，对一个已经进行过终端操作的流再次调用，会抛出异常。
二、函数 1、收集(collect) 归集(toList,toMap,toSet) //tolist List&lt;Integer> result = list.stream.filter(number -> number % 2 == 0).collect(Collector.toList); //tomap Map&lt;String, Integer> map = list.stream().filter( s -> { String[] split = s.split(","); int age = Integer.parseInt(split[1]); return age >= 24; } ).collect(Collector.toMap( s -> s.split(",")[0], (String s) -> { return Integer.parseInt(s.split(",")[1]); } )); //toset List&lt;Integer> list = Arrays.asList(1, 6, 3, 4, 6, 7, 9, 6, 20); List&lt;Integer> listNew = list.stream().filter(x -> x % 2 == 0).collect(Collectors.toList()); Set&lt;Integer> set = list.stream().filter(x -> x % 2 == 0).collect(Collectors.toSet()); 统计(count,averaging) Collectors提供了一系列用于数据统计的静态方法：
计数： count 平均值：averagingInt、averagingLong、averagingDouble 最值： maxBy、minBy 求和： summingInt、summingLong、summingDouble 统计以上所有：summarizingInt、summarizingLong、summarizingDouble
案例：统计员工人数、平均工资、工资总额、最高工资。
List&lt;Person> personList = new ArrayList&lt;Person>(); personList.add(new Person("Tom", 8900, 23, "male", "New York")); personList.add(new Person("Jack", 7000, 25, "male", "Washington")); personList.add(new Person("Lily", 7800, 21, "female", "Washington")); // 求总数 Long count = personList.stream().collect(Collectors.counting()); // 求平均工资 Double average = personList.stream().collect(Collectors.averagingDouble(Person::getSalary)); // 求最高工资 Optional&lt;Integer> max = personList.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compare)); // 求工资之和 Integer sum = personList.stream().collect(Collectors.summingInt(Person::getSalary)); // 一次性统计所有信息 DoubleSummaryStatistics collect = personList.stream().collect(Collectors.summarizingDouble(Person::getSalary)); System.out.println("员工总数：" + count); System.out.println("员工平均工资：" + average); System.out.println("员工工资总和：" + sum); System.out.println("员工工资所有统计：" + collect); 运行结果：
员工总数：3 员工平均工资：7900.0 员工工资总和：23700 员工工资所有统计：DoubleSummaryStatistics{count=3, sum=23700.000000,min=7000.000000, average=7900.000000, max=8900.000000} 分组(partitioningBy/gro..) partitioningBy/groupingBy
分区：将stream按条件分为两个Map，比如员工按薪资是否高于8000分为两部分。 分组：将集合分为多个Map，比如员工按性别分组。有单级分组和多级分组。 List&lt;Person> personList = new ArrayList&lt;Person>(); personList.add(new Person("Tom", 8900, "male", "New York")); personList.add(new Person("Jack", 7000, "male", "Washington")); personList.add(new Person("Lily", 7800, "female", "Washington")); personList.add(new Person("Anni", 8200, "female", "New York")); personList.add(new Person("Owen", 9500, "male", "New York")); personList.add(new Person("Alisa", 7900, "female", "New York")); // 将员工按薪资是否高于8000分组 Map&lt;Boolean, List&lt;Person>> part = personList.stream() .collect(Collectors.partitioningBy(x -> x.getSalary() > 8000)); // 将员工按性别分组 Map&lt;String, List&lt;Person>> group = personList.stream() .collect(Collectors.groupingBy(Person::getSex)); // 将员工先按性别分组，再按地区分组 Map&lt;String, Map&lt;String, List&lt;Person>>> group2 = personList.stream() .collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea))); System.out.println("员工按薪资是否大于8000分组情况：" + part); System.out.println("员工按性别分组情况：" + group); System.out.println("员工按性别、地区：" + group2); 案例二：
//分组数目 System.out.println("分组数目："); Integer groupCount = peopleList .stream() .collect(Collectors .collectingAndThen(Collectors.groupingBy(People::getName), Map::size)); System.out.println(groupCount); System.out.println("-------------------------------------"); //按照名字分组 System.out.println("按照名字分组"); System.out.println(peopleList.stream() .collect(Collectors.groupingBy(People::getName)) ); System.out.println("-------------------------------------"); //按照名字分组(分组的结果是一个map)，并统计每一个分组(map中的每一个value)中的元素数目 System.out.println("统计每一个分组(map中的每一个value)中的元素数目"); System.out.println(peopleList.stream() .collect(Collectors.groupingBy(People::getName, Collectors.counting()))); System.out.println("-------------------------------------"); //按照名字分组(分组的结果是一个map)，并取出每一组的最大值 System.out.println("取出每一组的最大值"); System.out.println(peopleList.stream() .collect(Collectors .groupingBy(People::getName, Collectors.maxBy( new Comparator&lt;People>() { @Override public int compare(People o1, People o2) { return o1.getAge() - o2.getAge(); } })))); //7 //{小猪=[People{age=31, gender=0, name='小猪'},People{age=20, gender=0, name='小猪'},People{age=22, gender=0, name='小猪'}]} //{小猪=2,小龙=3,小白=4,小王=5} //{小猪=Optional[People{age=20, gender=0, name='小猪'}],小龙=Optional[People{age=30, gender=0, name='小龙'}]} 接合(joining) joining可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。
List&lt;Person> personList = new ArrayList&lt;Person>(); personList.add(new Person("Tom", 8900, 23, "male", "New York")); personList.add(new Person("Jack", 7000, 25, "male", "Washington")); personList.add(new Person("Lily", 7800, 21, "female", "Washington")); String names = personList.stream() .map(p -> p.getName()) .collect(Collectors.joining(",")); System.out.println("所有员工的姓名：" + names); List&lt;String> list = Arrays.asList("A", "B", "C"); String string = list.stream() .collect(Collectors.joining("-")); System.out.println("拼接后的字符串：" + string); 运行结果： 所有员工的姓名：Tom,Jack,Lily 拼接后的字符串：A-B-C 归约(reducing) Collectors类提供的reducing方法，相比于stream本身的reduce方法，增加了对自定义归约的支持。
List&lt;Person> personList = new ArrayList&lt;Person>(); personList.add(new Person("Tom", 8900, 23, "male", "New York")); personList.add(new Person("Jack", 7000, 25, "male", "Washington")); personList.add(new Person("Lily", 7800, 21, "female", "Washington")); // 每个员工减去起征点后的薪资之和（这个例子并不严谨，但一时没想到好的例子） Integer sum = personList.stream() .collect(Collectors.reducing(0, Person::getSalary, (i, j) -> (i + j - 5000))); System.out.println("员工扣税薪资总和：" + sum); // stream的reduce Optional&lt;Integer> sum2 = personList.stream() .map(Person::getSalary).reduce(Integer::sum); System.out.println("员工薪资总和：" + sum2.get()); 运行结果： 员工扣税薪资总和：8700 员工薪资总和：23700 2、过滤(filter) List&lt;String>strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl"); // 获取空字符串的数量 long count = strings.stream() .filter(string -> string.isEmpty()) .count(); // filter().limit(2) 案例二： 筛选员工中工资高于8000的人，并形成新的集合。 形成新集合依赖collect（收集），后文有详细介绍。
List&lt;Person> personList = new ArrayList&lt;Person>(); personList.add(new Person("Tom", 8900, 23, "male", "New York")); personList.add(new Person("Jack", 7000, 25, "male", "Washington")); personList.add(new Person("Lily", 7800, 21, "female", "Washington")); personList.add(new Person("Anni", 8200, 24, "female", "New York")); personList.add(new Person("Owen", 9500, 25, "male", "New York")); personList.add(new Person("Alisa", 7900, 26, "female", "New York")); List&lt;String> fiterList = personList.stream() .filter(x -> x.getSalary() > 8000) .map(Person::getName) .collect(Collectors.toList()); System.out.print("高于8000的员工姓名：" + fiterList); 3、归约(reduce) 归约，也称缩减，顾名思义，是把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作。
案例一：求Integer集合的元素之和、乘积和最大值。
List&lt;Integer> list = Arrays.asList(1, 3, 2, 8, 11, 4); // 求和方式1 Optional&lt;Integer> sum = list.stream().reduce((x, y) -> x + y); // 求和方式2 Optional&lt;Integer> sum2 = list.stream().reduce(Integer::sum); // 求和方式3 Integer sum3 = list.stream().reduce(0, Integer::sum); // 求乘积 Optional&lt;Integer> product = list.stream().reduce((x, y) -> x * y); // 求最大值方式1 Optional&lt;Integer> max = list.stream().reduce((x, y) -> x > y ? x : y); // 求最大值写法2 Integer max2 = list.stream().reduce(1, Integer::max); System.out.println("list求和：" + sum.get() + "," + sum2.get() + "," + sum3); System.out.println("list求积：" + product.get()); System.out.println("list求和：" + max.get() + "," + max2); 4、聚合(count,max,min) 过滤出来数据数量合
long count = strings.stream().filter(string -> string.isEmpty()).count(); public class StreamTest { public static void main(String[] args) { List&lt;String> list = Arrays.asList("adnm", "admmt", "pot", "xbangd", "weoujgsd"); Optional&lt;String> max = list.stream().max(Comparator.comparing(String::length)); System.out.println("最长的字符串：" + max.get()); } } 5、遍历匹配(for,find,match) String流的生命周期：同一个流只能遍历一次，遍历完后，这个流就已经被消费掉了。你如果还需要在遍历，可以从原始数据源那里再获得一个新的流来重新遍历一遍。
Random random = new Random(); random.ints().limit(10).forEach(System.out::println); List&lt;Integer> list = Arrays.asList(7, 6, 9, 3, 8, 2, 1); // 遍历输出符合条件的元素 list.stream().filter(x -> x > 6).forEach(System.out::println); // 匹配第一个 Optional&lt;Integer> findFirst = list.stream().filter(x -> x > 6).findFirst(); // 匹配任意（适用于并行流） Optional&lt;Integer> findAny = list.parallelStream().filter(x -> x > 6).findAny(); // 是否包含符合特定条件的元素 boolean anyMatch = list.stream().anyMatch(x -> x > 6); System.out.println("匹配第一个值：" + findFirst.get()); System.out.println("匹配任意一个值：" + findAny.get()); System.out.println("是否存在大于6的值：" + anyMatch); 6、映射(map,faltMap) map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：
map：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。 // 获取对应的平方数 List&lt;Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); List&lt;Integer> squaresList = numbers.stream().map( i -> i*i).distinct().collect(Collectors.toList()); //获取10个姓王的人并输出。 List&lt;Person> personList = fromDB(); // 获得List&lt;Person> personList.stream() .filter(item->item.age == 70) // 过滤条件 .limit(10) // limit限制条件 .filter(item->item.name.startWith("王")) // 过滤条件 .map(item->item.name) // 获得姓名 .forEach(System.out::println); //获取一个String 类型的Stream流 //使用map方法，把字符串类型的整数，转换（映射）为Integer类型的整数 //遍历stream2流 Stream&lt;String> stream = Stream.of("1", "2", "3", "4"); Stream&lt;Integer> stream2 = stream.map(s-> Integer.parseInt(s)); stream2.forEach(i-> System.out.println(i)); 7、提取组合(concat,limit ,sk..) //concat Stream.concat(stream1, stream2).forEach(name ->{ Actor actor = new Actor(name); System.out.println(name) }); //limit Random random = new Random(); random.ints().limit(10).forEach(System.out::println); String[] arr1 = { "a", "b", "c", "d" }; String[] arr2 = { "d", "e", "f", "g" }; Stream&lt;String> stream1 = Stream.of(arr1); Stream&lt;String> stream2 = Stream.of(arr2); // concat:合并两个流 distinct：去重 List&lt;String> newList = Stream.concat(stream1, stream2) .distinct() .collect(Collectors.toList()); // limit：限制从流中获得前n个数据 List&lt;Integer> collect = Stream.iterate(1, x -> x + 2) .limit(10) .collect(Collectors.toList()); // skip：跳过前n个数据 List&lt;Integer> collect2 = Stream.iterate(1, x -> x + 2) .skip(1) .limit(5) .collect(Collectors.toList()); System.out.println("流合并：" + newList); System.out.println("limit：" + collect); System.out.println("skip：" + collect2); 8、排序(Sorted) Random random = new Random(); random.ints().limit(10).sorted().forEach(System.out::println); 9、Collectors Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：
List&lt;String>strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl"); List&lt;String> filtered = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.toList()); System.out.println("筛选列表: " + filtered); //筛选出来的string字符进行拼接 String mergedString = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.joining(", ")); System.out.println("合并字符串: " + mergedString); 三、统计 List&lt;Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); IntSummaryStatistics stats = numbers.stream().mapToInt((x) -> x).summaryStatistics(); System.out.println("列表中最大的数 : " + stats.getMax()); System.out.println("列表中最小的数 : " + stats.getMin()); System.out.println("所有数之和 : " + stats.getSum()); System.out.println("平均数 : " + stats.getAverage()); 四、流创建 1、随机数流 
Random rand = new Random(47); show(rand.ints().boxed()); show(rand.longs().boxed()); show(rand.doubles().boxed()); // 控制上限和下限： show(rand.ints(10, 20).boxed()); show(rand.longs(50, 100).boxed()); show(rand.doubles(20, 30).boxed()); // 控制流大小： show(rand.ints(2).boxed()); show(rand.longs(2).boxed()); show(rand.doubles(2).boxed()); // 控制流的大小和界限 show(rand.ints(3, 3, 9).boxed()); show(rand.longs(3, 12, 22).boxed()); show(rand.doubles(3, 11.5, 12.3).boxed()); 具体看on java 8 第14章，流创建、随机数流 2、int类型的范围 public class Ranges { public static void main(String[] args) { // 传统方法: int result = 0; for (int i = 10; i &lt; 20; i++) result += i; System.out.println(result); // for-in 循环: result = 0; for (int i : range(10, 20).toArray()) result += i; System.out.println(result); // 使用流: System.out.println(range(10, 20).sum()); } }</content></entry><entry><title>String字符串</title><url>https://zhang4014439175.github.io/post/string/</url><categories><category>Java-Base</category></categories><tags><tag>Java</tag><tag>String</tag></tags><content type="html"> String是C++、Java、VB等编程语言中的字符串，字符串是一个特殊的对象，属于引用类型。在Java、C#中，String类对象创建后，字符串一旦初始化就不能更改，因为String类中所有字符串都是常量，数据是无法更改，由于String对象的不可变，所以可以共享。
一、Collectors.joining() 1、拼接字符串 List&lt;String> list = Arrays.asList("Ram","Shyam","Shiv","Mahesh"); String result= list.stream().collect(Collectors.joining()); System.out.println(result); //RamShyamShivMahesh result= list.stream().collect(Collectors.joining(",")); System.out.println(result); //Ram,Shyam,Shiv,Mahesh result= list.stream().collect(Collectors.joining("-","[","]")); System.out.println(result); //[Ram-Shyam-Shiv-Mahesh] 2、拼接对象 package com.concretepage; import java.util.List; import java.util.stream.Collectors; public class JoiningExampleWithListOfObject { public static void main(String[] args) { List&lt;Person> list = new ArrayList&lt;>(); list.add(new Person("Ram", 23)); list.add(new Person("Shyam", 20)); list.add(new Person("Shiv", 25)); list.add(new Person("Mahesh", 30)); String result= list.stream() .map(p -> p.getName()) .collect(Collectors.joining()); System.out.println(result); //RamShyamShivMahesh String result= list.stream() .map(p -> p.getName()) .collect(Collectors.joining("|")); System.out.println(result); //Ram|Shyam|Shiv|Mahesh String result= list.stream().map(p -> p.getName()).collect(Collectors.joining("-","[","]")); System.out.println(result); //[Ram-Shyam-Shiv-Mahesh] String result= list.stream() .map(p -> String.valueOf(p.getAge())) .collect(Collectors.joining()); System.out.println(result); //23202530 String result= list.stream() .map(p -> String.valueOf(p.getAge())) .collect(Collectors.joining("|")); System.out.println(result); //23|20|25|30 String result= list.stream() .map(p -> String.valueOf(p.getAge())) .collect(Collectors.joining("-","[","]")); System.out.println(result); //[23-20-25-30] String result= list.stream() .map(p -> p.getName()+"-" + p.getAge()) .collect(Collectors.joining("|")); System.out.println(result); //Ram-23|Shyam-20|Shiv-25|Mahesh-30 String result= list.stream() .map(p -> p.getName()+"-" + p.getAge()) .collect(Collectors.joining("|","[","]")); System.out.println(result); //[Ram-23|Shyam-20|Shiv-25|Mahesh-30] } } 3、遍历ArrayList中的元素
List&lt;Coffee> coffees = Stream.generate(new CoffeeSupplier()) .limit(10) .collect(Collectors.toList()); System.out.println(coffees); toString() 打印出类的内存地址
@Override public String toString() { //return " InfiniteRecursion address: " + this + "\n" //如果你真的想要打印对象的内存地址，应该调用 Object.toString() 方法，这才是负责此任务的方法。所以，不要使用 this，而是应该调用 super.toString() 方法。 } public static void main(String[] args) { Stream.generate(InfiniteRecursion::new) .limit(10) .forEach(System.out::println); } 二、常见方法 length()
charAt() 获取String中索引位置上的char
getChars()、getBytes() 复制char或byte到一个目标数组中
toCharArray() 生成一个char[]，包含String中的所有字符
equals()、equalsIgnoreCase() 比较两个String的内容是否相同。如果相同，结果为true
compareTo()、compareToIgnoreCase()
​ 按词典顺序比较String的内容，比较结果为负数、零或正数。注意，大小写不等价
contains()
contentEquals() 如果该String对象与参数的内容完全一致，则返回true
isEmpty() 返回boolean结果，以表明String对象的长度是否为0
​ Stringutils.isEmpty() 来判断是否为空null
regionMatches() 返回boolean结果，以表明所比较区域是否相等
startsWith() 返回boolean结果，以表明该String是否以传入参数开始
endsWith() 返回boolean结果，以表明此参数是否是该字符串的后缀
indexOf() 返回在String中的起始索引，如果不包含此参数，就返回-1；
lastIndexOf() lastIndexOf()是从后往前搜索
matches() 返回boolean结果，以表明该String和给出的正则表达式是否匹配
split() 按照正则表达式拆分String，返回一个结果数组
join() 用分隔符拼接字符片段，产生一个新的String
substring() 返回一个新的String对象，以包含参数指定的子串
concat() 拼接字符串
replace() 返回替换字符后的新String对象。如果没有替换发生，则返回原始的String对象
replaceFirst() 返回替换首个目标字符串后的String对象
replaceAll() 返回替换所有目标字符串后的String对象
toLowerCase()
toUpperCase()
trim() 将String两端的空白符删除后，返回一个新的String对象。
​ 如果没有任何改变，则返回原始的String对象
valueOf()
intern() 为每个唯一的字符序列生成一个且仅生成一个String引用。
format() 返回格式化结果String
1、练习 从0 - 100 共25个数字
String result = new Random(47) .ints(25, 0, 100) .mapToObj(Integer::toString) .collect(Collectors.joining(",")); 三、printf() System.out.printf("Row 1: [%d %f]%n", x, y); 这一行代码在运行的时候，首先将 x 的值插入到 %d_ 的位置，然后将 y 的值插入到 %f 的位置。这些占位符叫做格式修饰符，它们不仅指明了插入数据的位置，同时还指明了将会插入什么类型的变量，以及如何格式化。在这个例子中 %d 表示 x 是一个整数，%f 表示 y 是一个浮点数（float 或者 double）。
int x = 5; double y = 5.332542; // The old way: System.out.println("Row 1: [" + x + " " + y + "]"); // The new way: System.out.format("Row 1: [%d %f]%n", x, y); // or System.out.printf("Row 1: [%d %f]%n", x, y); /* Output: Row 1: [5 5.332542] Row 1: [5 5.332542] Row 1: [5 5.332542] */ 格式化修饰符 f.format("%-15s %5s %10s%n", "Item", "Qty", "Price"); f.format("%-15s %5s %10s%n", "----", "---", "-----"); f.format("%-15.15s %5d %10.2f%n", name, qty, price); receiptBuilder.add("Jack's Magic Beans", 4, 4.25); receiptBuilder.add("Princess Peas", 3, 5.1); receiptBuilder.add("Three Bears Porridge", 1, 14.29); total += price * qty; f.format("%-15s %5s %10.2f%n", "Tax", "", total * 0.06); f.format("%-15s %5s %10s%n", "", "", "-----"); f.format("%-15s %5s %10.2f%n", "Total", "", total * 1.06); Formatter转换 下面的表格展示了最常用的类型转换：
类型 含义 d 整型（十进制） c Unicode字符 b Boolean值 s String f 浮点数（十进制） e 浮点数（科学计数） x 整型（十六进制） h 散列码（十六进制） % 字面值“%” 四、正则表达式 System.out.println("-1234".matches("-?\\d+")); System.out.println("5678".matches("-?\\d+")); System.out.println("+911".matches("-?\\d+")); System.out.println("+911".matches("(-|\\+)?\\d+")); /* Output: true true false true */ (-|\+)?
这个正则表达式表示字符串的起始字符可能是一个 - 或 +，或者二者都没有（因为后面跟着 ? 修饰符）。因为字符 + 在正则表达式中有特殊的意义，所以必须使用 \ 将其转义，使之成为表达式中的一个普通字符。
String类还自带了一个非常有用的正则表达式工具——split() 方法，其功能是“将字符串从正则表达式匹配的地方切开。”
public class Splitting { public static String knights = "Then, when you have found the shrubbery, " + "you must cut down the mightiest tree in the " + "forest...with... a herring!"; public static void split(String regex) { System.out.println( Arrays.toString(knights.split(regex))); } public static void main(String[] args) { split(" "); // Doesn't have to contain regex chars split("\\W+"); // Non-word characters split("n\\W+"); // 'n' followed by non-words //按空格来划分字符串。 //一个非单词字符（如果 W 小写，\\w，则表示一个单词字符）。 //表示“字母n后面跟着一个或多个非单词字符。” } } /* Output: [Then,, when, you, have, found, the, shrubbery,, you, must, cut, down, the, mightiest, tree, in, the, forest...with..., a, herring!] [Then, when, you, have, found, the, shrubbery, you, must, cut, down, the, mightiest, tree, in, the, forest, with, a, herring] [The, whe, you have found the shrubbery, you must cut dow, the mightiest tree i, the forest...with... a herring!] */ 用正则表达式进行替换操作时，你可以只替换第一处匹配，也可以替换所有的匹配：
// strings/Replacing.java public class Replacing { static String s = Splitting.knights; public static void main(String[] args) { System.out.println(s.replaceFirst("f\\w+", "located")); //以字母 f 开头，后面跟一个或多个字母（注意这里的 w 是小写的）。并且只替换掉第一个匹配的部分，所以 “found” 被替换成 “located”。 System.out.println(s.replaceAll("shrubbery|tree|herring","banana")); //第二个表达式要匹配的是三个单词中的任意一个，因为它们以竖线分割表示“或”，并且替换所有匹配的部分。 } } /* Output: Then, when you have located the shrubbery, you must cut down the mightiest tree in the forest...with... a herring! Then, when you have found the banana, you must cut down the mightiest banana in the forest...with... a banana! */ 表达式 含义 B 指定字符B \xhh 十六进制值为0xhh的字符 \uhhhh 十六进制表现为0xhhhh的Unicode字符 \t 制表符Tab \n 换行符 \r 回车 \f 换页 \e 转义（Escape） 当你学会了使用字符类（character classes）之后，正则表达式的威力才能真正显现出来。以下是一些创建字符类的典型方式，以及一些预定义的类：
表达式 含义 . 任意字符 [abc] 包含a、b或c的任何字符（和`a [^abc] 除a、b和c之外的任何字符（否定） [a-zA-Z] 从a到z或从A到Z的任何字符（范围） [abc[hij]] a、b、c、h、i、j中的任意字符（与`a [a-z&amp;&amp;[hij]] 任意h、i或j（交） \s 空白符（空格、tab、换行、换页、回车） \S 非空白符（[^\s]） \d 数字（[0-9]） \D 非数字（[^0-9]） \w 词字符（[a-zA-Z_0-9]） \W 非词字符（[^\w]） for(String pattern : new String[]{ "Rudolph", "[rR]udolph", "[rR][aeiou][a-z]ol.*", "R.*" }) System.out.println("Rudolph".matches(pattern)); /* Output: true true true true */ 1、量词 贪婪型： 量词总是贪婪的，除非有其他的选项被设置。贪婪表达式会为所有可能的模式发现尽可能多的匹配。导致此问题的一个典型理由就是假定我们的模式仅能匹配第一个可能的字符组，如果它是贪婪的，那么它就会继续往下匹配。
勉强型： 用问号来指定，这个量词匹配满足模式所需的最少字符数。因此也被称作懒惰的、最少匹配的、非贪婪的或不贪婪的。
占有型： 目前，这种类型的量词只有在 Java 语言中才可用（在其他语言中不可用），并且也更高级，因此我们大概不会立刻用到它。当正则表达式被应用于 String 时，它会产生相当多的状态，以便在匹配失败时可以回溯。而“占有的”量词并不保存这些中间状态，因此它们可以防止回溯。它们常常用于防止正则表达式失控，因此可以使正则表达式执行起来更高效。
贪婪型 勉强型 占有型 如何匹配 X? X?? X?+ 一个或零个X X* X*? X*+ 零个或多个X X+ X+? X++ 一个或多个X X{n} X{n}? X{n}+ 恰好n次X X{n,} X{n,}? X{n,}+ 至少n次X X{n,m} X{n,m}? X{n,m}+ X至少n次，但不超过m次 A(B(C))D
中有三个组：组 0 是 ABCD，组 1 是 BC，组 2 是 C。
Matcher 对象提供了一系列方法，用以获取与组相关的信息：
public int groupCount() 返回该匹配器的模式中的分组数目，组 0 不包括在内。 public String group() 返回前一次匹配操作（例如 find()）的第 0 组（整个匹配）。 public String group(int i) 返回前一次匹配操作期间指定的组号，如果匹配成功，但是指定的组没有匹配输入字符串的任何部分，则将返回 null。 public int start(int group) 返回在前一次匹配操作中寻找到的组的起始索引。 public int end(int group) 返回在前一次匹配操作中寻找到的组的最后一个字符索引加一的值。 2、元字符 元字符：即为有特定含义的字符，常见的元字符如下
代码 说明 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始（在集合字符里[^a]表示非（不匹配）的意思 $ 匹配字符串的结束 详解和示例：
（1）. 匹配任何任意字符 例如 . 可以匹配 1，n，*，+，- ,等
（2）\d\w\s 匹配第一个字符为数字，第二个字符为字母或数字、或下划线或汉字，第三字符为空格的字符串 例如：11 ，2a , 1_
（3）^\d\d\d$ 匹配三个全部都为数字的字符串 例如： 123,456,789
还可以用于验证输入的字符串是否符合qq（身份证号）的验证 ： 例如：^\d{8}$ 匹配8位数字的qq号，^\d{15}&amp;匹配15位均为数字的身份证号 （4）\bOlive\b 匹配单词Olive 例如： I Love Oliver and Olive .这个时候返回的是Olive 而不是Oliver,因为\b&hellip;.\b返回的匹配的单词
3、反义字符 反义字符：多用于查找除某个字符以外其他任意字符均可以的情况
常用的反义字符如下：
代码/语法 说明 \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 详解和示例：
（1）\W 匹配除字母、数字、下划线、汉字以为的字符形如 +，-，*
（2）\S 匹配除空格以外的任意字符形如：1，* ，）
（3）[^abcde]匹配除abcde以为的其他字符 如 e，f，g，h
4、限定字符 限定字符多用于重复匹配次数
常用的限定字符如下
代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 详解和示例：
（1）\d* 匹配重复0次或多次数字 例如:可能为空 或 任意数字 （2,3。。。。）
（2）\d+ 匹配重复1次或多次数字 例如:可能为1个或多个数字 1,23,234,2345，&hellip;&hellip;..
（3）\d? 匹配重复次个或者一次数字 例如：可能为空或者任意的一个数字（1,2，。。。）
（4）\d{8}匹配重复8次数字 例如：123456768
（5）\d{4,}匹配重复至少4次数字 例如：1234,12345,124244,。。。。。
（6）^\d{8,11}$ 匹配重复8-11次数字 例如：12345678,123456789,1234567890,12345678901
5、转义字符 在实际的开发中，可能会遇到要比配元字符的情况，这个时候就需要进行字符转义，如元字符 . * \ 需要转换为. * \
例如： 需要匹配qq邮箱 \d{8,}+qq+.+com 在这里的. 就需要加斜杠
6、字符分枝 字符分枝多用于满足不同情况的选择，用“|”将不同的条件分割开来，比如有些固定电话区号有三位，有些有四位，这个时候可以采用字符分枝
例如：\d{3}-\d{8}|\d{4}-\d{8} 可以匹配两种不同长度区号的固定电话
下边的IP地址正则表达式也有用到字符分枝
7、字符分组 字符分组多用于将多个字符重复，主要通过使用小括号()来进行分组
形如：（\d\w){3} 重复匹配3次（\d\w)
常用于表示IP地址 形如： ((25[0-5]|2[0-4][0-9]|[0-1]\d\d).){3}(25[0-5]|2[0-4][0-9]|[0-1]\d\d)
解析：先把IP地址分为两部分一部分是123.123.123. 另一部分是123，又因Ip最大值为255，所以先使用分组，然后在组里边再进行选择，组里也有三部分，0-199,200-249,250-255，分别和上述的表达是对应，最后还要注意分组之后还要加上一个.，因为是元字符所以要转义故加上. 然后再把这部分整体看做是一个组，重复三次，再加上仅有数字的一组也就是不带.的那一组即可完成IP地址的校验
常用分组语法
分类 代码/语法 说明 (exp) 匹配exp,并捕获文本到自动命名的组里 捕 (?exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?&rsquo;name&rsquo;exp) 获 (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零 (?=exp) 匹配exp前面的位置 宽 (?&lt;=exp) 匹配exp后面的位置 断 (?!exp) 匹配后面跟的不是exp的位置 言 (?&lt;!exp) 匹配前面不是exp的位置 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 8、懒惰匹配和贪婪匹配 贪婪匹配：正则表达式中包含重复的限定符时，通常的行为是匹配尽可能多的字符。
懒惰匹配，有时候需要匹配尽可能少的字符。
例如： a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。但是我们此时可能需要匹配的是ab这样的话就需要用到懒惰匹配了。懒惰匹配会匹配尽可能少的字符
常用的懒惰匹配限定符如下
代码/语法 说明 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 9、后向引用 后向引用用于重复搜索前面某个分组匹配的文本。
使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推
示例：\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。
这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。
你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?\w+)(或者把尖括号换成&rsquo;也行：(?&lsquo;Word&rsquo;\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k,所以上一个例子也可以写成这样：\b(?\w+)\b\s+\k\b
10、零宽断言 有时候需要查找某些匹配之前或之后的东西，这个时候就需要用到们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言
(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如 \b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I&rsquo;m singing while you&rsquo;re dancing.时，它会匹配sing和danc。
(?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。
11、其他语法 12、常用的实用正则表达式整理 只能输入数字："^[0-9]*$"。
　只能输入n位的数字："^&ldquo;d{n}$"。
　只能输入至少n位的数字："^&ldquo;d{n,}$"。
　只能输入m~n位的数字：。"^&ldquo;d{m,n}$&rdquo;
　只能输入零和非零开头的数字："^(0|[1-9][0-9]*)$"。
　只能输入有两位小数的正实数："^[0-9]+(.[0-9]{2})?$"。
　只能输入有1~3位小数的正实数："^[0-9]+(.[0-9]{1,3})?$"。
　只能输入非零的正整数："^"+?[1-9][0-9]*$"。
　只能输入非零的负整数："^&rdquo;-[1-9][]0-9&rdquo;*$。
　只能输入长度为3的字符："^.{3}$"。
　只能输入由26个英文字母组成的字符串："^[A-Za-z]+$"。
　只能输入由26个大写英文字母组成的字符串："^[A-Z]+$"。
　只能输入由26个小写英文字母组成的字符串："^[a-z]+$"。
　只能输入由数字和26个英文字母组成的字符串："^[A-Za-z0-9]+$"。
　只能输入由数字、26个英文字母或者下划线组成的字符串："^&ldquo;w+$"。
　验证用户密码："^[a-zA-Z]&ldquo;w{5,17}$&ldquo;正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。
　验证是否含有^%&amp;’,;=?$&ldquo;&ldquo;等字符：&rdquo;[^%&amp;’,;=?$&ldquo;x22]+"。
　只能输入汉字："^[&ldquo;u4e00-&ldquo;u9fa5]{0,}$&rdquo;
　验证Email地址："^&ldquo;w+([-+.]&ldquo;w+)@&ldquo;w+([-.]&ldquo;w+)&rdquo;.&ldquo;w+([-.]&ldquo;w+)*$"。
　验证InternetURL："^http://([&ldquo;w-]+&rdquo;.)+[&ldquo;w-]+(/[&ldquo;w-./?%&amp;=]*)?$"。
　验证电话号码："^(&rdquo;(&ldquo;d{3,4}-)|&ldquo;d{3.4}-)?&ldquo;d{7,8}$&ldquo;正确格式为：&ldquo;XXX-XXXXXXX&rdquo;、&ldquo;XXXX- XXXXXXXX&rdquo;、&ldquo;XXX-XXXXXXX&rdquo;、&ldquo;XXX-XXXXXXXX&rdquo;、&ldquo;XXXXXXX"和"XXXXXXXX&rdquo;。
　验证身份证号(15位或18位数字)："^&ldquo;d{15}|&ldquo;d{18}$"。
　验证一年的12个月："^(0?[1-9]|1[0-2])$&ldquo;正确格式为：&ldquo;01"～"09"和"1"～"12&rdquo;。
　验证一个月的31天："^((0?[1-9])|((1|2)[0-9])|30|31)$&ldquo;正确格式为;&ldquo;01"～"09"和"1"～"31&rdquo;。</content></entry><entry><title>MySql基础入门安装教程</title><url>https://zhang4014439175.github.io/post/mysql%E5%AE%89%E8%A3%85/</url><categories><category>MySql</category></categories><tags><tag>MySql</tag><tag>Sql</tag></tags><content type="html">  MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。
一、MySQL数据库的介绍和安装 1.MySQL数据库介绍 小型的数据库 开源免费(6版本之前免费) 所属于Oracle公司 2.MySQL数据库安装 通过secureCRT工具连接Linux系统
上传 mysql 的安装包
alt + p -------> put d:/setup/mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar 解压 mysql 的安装包 mkdir mysql tar -xvf mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar -C mysql/ 安装客户端 cd mysql/ rpm -ivh mysql-community-client-5.7.27-1.el7.x86_64.rpm --force --nodeps 安装服务端 rpm -ivh mysql-community-server-5.7.27-1.el7.x86_64.rpm --force --nodeps 修改mysql默认字符集 vi /etc/my.cnf 添加如下内容： [mysqld] character-set-server=utf8 collation-server=utf8_general_ci -- 需要在最下方填写 [client] default-character-set=utf8 启动mysql服务 service mysqld start 登录mysql mysql -u root -p 敲回车，输入密码 初始密码查看：cat /var/log/mysqld.log 在root@localhost: 后面的就是初始密码 修改mysql登录密码 set global validate_password_policy=0; set global validate_password_length=1; set password=password('密码'); 授予远程连接权限 //授权 grant all privileges on *.* to 'root' @'%' identified by '密码'; //刷新 flush privileges; 关闭Linux系统防火墙 systemctl stop firewalld.service 3.MySQL数据库登录 sqlyog工具登录mysql</content></entry><entry><title>MySql基础入门（一）</title><url>https://zhang4014439175.github.io/post/mysql%E5%9F%BA%E7%A1%8001/</url><categories><category>MySql</category></categories><tags><tag>MySql</tag><tag>Sql</tag></tags><content type="html">  MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。
一、数据库的基本概念 1.为什么要学数据库？ 之前我们如果想将一些数据实现永久化存储，可以怎么做呢？没错。使用IO流的技术将数据保存到本地文件中 但是接下来我有这样一个需求：将下面的user.txt文件中的王五年龄修改为35 张三 23 男 李四 24 男 王五 25 女 赵六 26 女 周七 27 男 我们要如何实现呢？ 可以采用字符缓冲流，将每一行数据读取出来，封装为User对象。将多个User对象保存到集合中 然后遍历集合，将王五对象的年龄修改为35,再重新将集合中的对象信息写回到文件中 这一套操作太麻烦了，而现在我们有一种更加方便的方式来完成这个需求了，这种方式就是数据库！ 2.什么是数据库？ 用于存储和管理数据的仓库 英文单词为：DataBase，简称DB 3.数据库的好处？ 可以持久化存储数据 方便存储和管理数据 使用了统一的方式操作数据库 &ndash; SQL 4.常见的数据库有哪些？ 二、SQL语句 1.数据库、数据表、数据的关系介绍 数据库 用于存储和管理数据的仓库 一个库中可以包含多个数据表 数据表 数据库最重要的组成部分之一 它由纵向的列和横向的行组成(类似excel表格) 可以指定列名、数据类型、约束等 一个表中可以存储多条数据 数据 想要永久化存储的数据 2.SQL介绍 什么是SQL
Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”。 SQL通用语法
SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 数据库的注释： 单行注释：&ndash; 注释内容 #注释内容(mysql特有) 多行注释：/* 注释内容 */ SQL分类
DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 3.DDL-操作数据库 R(Retrieve)：查询
查询所有数据库 -- 查询所有数据库 SHOWDATABASES; 查询某个数据库的创建语句 -- 标准语法 SHOWCREATEDATABASE数据库名称;-- 查看mysql数据库的创建格式 SHOWCREATEDATABASEmysql; C(Create)：创建
创建数据库 -- 标准语法 CREATEDATABASE数据库名称;-- 创建db1数据库 CREATEDATABASEdb1;-- 创建一个已存在的数据库会报错 -- 错误代码：1007 Can't create database 'db1'; database exists CREATEDATABASEdb1; 创建数据库(判断，如果不存在则创建) -- 标准语法 CREATEDATABASEIFNOTEXISTS数据库名称;-- 创建数据库db2(判断，如果不存在则创建) CREATEDATABASEIFNOTEXISTSdb2; 创建数据库、并指定字符集 -- 标准语法 CREATEDATABASE数据库名称CHARACTERSET字符集名称;-- 创建数据库db3、并指定字符集utf8 CREATEDATABASEdb3CHARACTERSETutf8;-- 查看db3数据库的字符集 SHOWCREATEDATABASEdb3; 练习：创建db4数据库、如果不存在则创建，指定字符集为gbk -- 创建db4数据库、如果不存在则创建，指定字符集为gbk CREATEDATABASEIFNOTEXISTSdb4CHARACTERSETgbk;-- 查看db4数据库的字符集 SHOWCREATEDATABASEdb4; U(Update)：修改
修改数据库的字符集 -- 标准语法 ALTERDATABASE数据库名称CHARACTERSET字符集名称;-- 修改数据库db4的字符集为utf8 ALTERDATABASEdb4CHARACTERSETutf8;-- 查看db4数据库的字符集 SHOWCREATEDATABASEdb4; D(Delete)：删除
删除数据库 -- 标准语法 DROPDATABASE数据库名称;-- 删除db1数据库 DROPDATABASEdb1;-- 删除一个不存在的数据库会报错 -- 错误代码：1008 Can't drop database 'db1'; database doesn't exist DROPDATABASEdb1; 删除数据库(判断，如果存在则删除) -- 标准语法 DROPDATABASEIFEXISTS数据库名称;-- 删除数据库db2，如果存在 DROPDATABASEIFEXISTSdb2; 使用数据库
查询当前正在使用的数据库名称 -- 查询当前正在使用的数据库 SELECTDATABASE(); 使用数据库 -- 标准语法 USE数据库名称；-- 使用db4数据库 USEdb4; 4.DDL-操作数据表 R(Retrieve)：查询
查询数据库中所有的数据表 -- 使用mysql数据库 USEmysql;-- 查询库中所有的表 SHOWTABLES; 查询表结构 -- 标准语法 DESC表名;-- 查询user表结构 DESCuser; 查询表字符集 -- 标准语法 SHOWTABLESTATUSFROM库名LIKE'表名';-- 查看mysql数据库中user表字符集 SHOWTABLESTATUSFROMmysqlLIKE'user'; C(Create)：创建
创建数据表
标准语法 CREATETABLE表名(列名1数据类型1,列名2数据类型2,....列名n数据类型n);-- 注意：最后一列，不需要加逗号 数据类型 1.int：整数类型*ageint2.double:小数类型*scoredouble(5,2)*pricedouble3.date:日期，只包含年月日yyyy-MM-dd4.datetime:日期，包含年月日时分秒yyyy-MM-ddHH:mm:ss5.timestamp:时间戳类型包含年月日时分秒yyyy-MM-ddHH:mm:ss*如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值6.varchar：字符串*namevarchar(20):姓名最大20个字符*zhangsan8个字符张三2个字符 创建数据表 -- 使用db3数据库 USEdb3;-- 创建一个product商品表 CREATETABLEproduct(idINT,-- 商品编号 NAMEVARCHAR(30),-- 商品名称 priceDOUBLE,-- 商品价格 stockINT,-- 商品库存 insert_timeDATE-- 上架时间 ); 复制表 -- 标准语法 CREATETABLE表名LIKE被复制的表名;-- 复制product表到product2表 CREATETABLEproduct2LIKEproduct; U(Update)：修改
修改表名 -- 标准语法 ALTERTABLE表名RENAMETO新的表名;-- 修改product2表名为product3 ALTERTABLEproduct2RENAMETOproduct3; 修改表的字符集 -- 标准语法 ALTERTABLE表名CHARACTERSET字符集名称;-- 查看db3数据库中product3数据表字符集 SHOWTABLESTATUSFROMdb3LIKE'product3';-- 修改product3数据表字符集为gbk ALTERTABLEproduct3CHARACTERSETgbk;-- 查看db3数据库中product3数据表字符集 SHOWTABLESTATUSFROMdb3LIKE'product3'; 添加一列 -- 标准语法 ALTERTABLE表名ADD列名数据类型;-- 给product3表添加一列color ALTERTABLEproduct3ADDcolorVARCHAR(10); 修改列名称和数据类型 -- 修改数据类型 标准语法 ALTERTABLE表名MODIFY列名新数据类型;-- 将color数据类型修改为int ALTERTABLEproduct3MODIFYcolorINT;-- 查看product3表详细信息 DESCproduct3;-- 修改列名和数据类型 标准语法 ALTERTABLE表名CHANGE列名新列名新数据类型;-- 将color修改为address,数据类型为varchar ALTERTABLEproduct3CHANGEcoloraddressVARCHAR(30);-- 查看product3表详细信息 DESCproduct3; 删除列 -- 标准语法 ALTERTABLE表名DROP列名;-- 删除address列 ALTERTABLEproduct3DROPaddress; D(Delete)：删除
删除数据表 -- 标准语法 DROPTABLE表名;-- 删除product3表 DROPTABLEproduct3;-- 删除不存在的表，会报错 -- 错误代码：1051 Unknown table 'product3' DROPTABLEproduct3; 删除数据表(判断，如果存在则删除) -- 标准语法 DROPTABLEIFEXISTS表名;-- 删除product3表，如果存在则删除 DROPTABLEIFEXISTSproduct3; 5.DML-INSERT语句 新增表数据语法
新增格式1：给指定列添加数据 -- 标准语法 INSERTINTO表名(列名1,列名2,...)VALUES(值1,值2,...);-- 向product表添加一条数据 INSERTINTOproduct(id,NAME,price,stock,insert_time)VALUES(1,'手机',1999,22,'2099-09-09');-- 向product表添加指定列数据 INSERTINTOproduct(id,NAME,price)VALUES(2,'电脑',4999);-- 查看表中所有数据 SELECT*FROMproduct; 新增格式2：默认给全部列添加数据 -- 标准语法 INSERTINTO表名VALUES(值1,值2,值3,...);-- 默认给全部列添加数据 INSERTINTOproductVALUES(3,'电视',2999,18,'2099-06-06');-- 查看表中所有数据 SELECT*FROMproduct; 新增格式3：批量添加数据 -- 默认添加所有列数据 标准语法 INSERTINTO表名VALUES(值1,值2,值3,...),(值1,值2,值3,...),(值1,值2,值3,...);-- 批量添加数据 INSERTINTOproductVALUES(4,'冰箱',999,26,'2099-08-08'),(5,'洗衣机',1999,32,'2099-05-10');-- 查看表中所有数据 SELECT*FROMproduct;-- 给指定列添加数据 标准语法 INSERTINTO表名(列名1,列名2,...)VALUES(值1,值2,...),(值1,值2,...),(值1,值2,...);-- 批量添加指定列数据 INSERTINTOproduct(id,NAME,price)VALUES(6,'微波炉',499),(7,'电磁炉',899);-- 查看表中所有数据 SELECT*FROMproduct; 注意事项
列名和值的数量以及数据类型要对应 除了数字类型，其他数据类型的数据都需要加引号(单引双引都可以，推荐单引) 6.DML-UPDATE语句 修改表数据语法 -- 标准语法 UPDATE表名SET列名1=值1,列名2=值2,...[where条件];-- 修改手机的价格为3500 UPDATEproductSETprice=3500WHERENAME='手机';-- 查看所有数据 SELECT*FROMproduct;-- 修改电视的价格为1800、库存为36 UPDATEproductSETprice=1800,stock=36WHERENAME='电视';-- 修改电磁炉的库存为10 UPDATEproductSETstock=10WHEREid=7; 注意事项 修改语句中必须加条件 如果不加条件，则将所有数据都修改 7.DML-DELETE语句 删除表数据语法 -- 标准语法 DELETEFROM表名[WHERE条件];-- 删除product表中的微波炉信息 DELETEFROMproductWHERENAME='微波炉';-- 删除product表中库存为10的商品信息 DELETEFROMproductWHEREstock=10;-- 查看所有商品信息 SELECT*FROMproduct; 注意事项 删除语句中必须加条件 如果不加条件，则将所有数据删除 8.DQL-单表查询 数据准备(直接复制执行即可) -- 创建db1数据库 CREATEDATABASEdb1;-- 使用db1数据库 USEdb1;-- 创建数据表 CREATETABLEproduct(idINT,-- 商品编号 NAMEVARCHAR(20),-- 商品名称 priceDOUBLE,-- 商品价格 brandVARCHAR(10),-- 商品品牌 stockINT,-- 商品库存 insert_timeDATE-- 添加时间 );-- 添加数据 INSERTINTOproductVALUES(1,'华为手机',3999,'华为',23,'2088-03-10'),(2,'小米手机',2999,'小米',30,'2088-05-15'),(3,'苹果手机',5999,'苹果',18,'2088-08-20'),(4,'华为电脑',6999,'华为',14,'2088-06-16'),(5,'小米电脑',4999,'小米',26,'2088-07-08'),(6,'苹果电脑',8999,'苹果',15,'2088-10-25'),(7,'联想电脑',7999,'联想',NULL,'2088-11-11'); 查询语法 select字段列表from表名列表where条件列表groupby分组字段having分组之后的条件orderby排序limit分页限定 查询全部 -- 标准语法 SELECT*FROM表名;-- 查询product表所有数据 SELECT*FROMproduct; 查询部分
多个字段查询 -- 标准语法 SELECT列名1,列名2,...FROM表名;-- 查询名称、价格、品牌 SELECTNAME,price,brandFROMproduct; 去除重复查询 注意：只有全部重复的才可以去除 -- 标准语法 SELECTDISTINCT列名1,列名2,...FROM表名;-- 查询品牌 SELECTbrandFROMproduct;-- 查询品牌，去除重复 SELECTDISTINCTbrandFROMproduct; 计算列的值(四则运算) -- 标准语法 SELECT列名1运算符(+-*/)列名2FROM表名;/* 计算列的值 标准语法： SELECT 列名1 运算符(+ - * /) 列名2 FROM 表名; 如果某一列为null，可以进行替换 ifnull(表达式1,表达式2) 表达式1：想替换的列 表达式2：想替换的值 */-- 查询商品名称和库存，库存数量在原有基础上加10 SELECTNAME,stock+10FROMproduct;-- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断 SELECTNAME,IFNULL(stock,0)+10FROMproduct; 起别名 -- 标准语法 SELECT列名1,列名2,...AS别名FROM表名;-- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断。起别名为getSum SELECTNAME,IFNULL(stock,0)+10ASgetsumFROMproduct;SELECTNAME,IFNULL(stock,0)+10getsumFROMproduct; 条件查询
条件分类 符号 功能 > 大于 &lt; 小于 >= 大于等于 &lt;= 小于等于 = 等于 &lt;> 或 != 不等于 BETWEEN &hellip; AND &hellip; 在某个范围之内(都包含) IN(&hellip;) 多选一 LIKE 占位符 模糊查询 _单个任意字符 %多个任意字符 IS NULL 是NULL IS NOT NULL 不是NULL AND 或 &amp;&amp; 并且 OR 或 || 或者 NOT 或 ! 非，不是 条件查询语法 -- 标准语法 SELECT列名FROM表名WHERE条件;-- 查询库存大于20的商品信息 SELECT*FROMproductWHEREstock>20;-- 查询品牌为华为的商品信息 SELECT*FROMproductWHEREbrand='华为';-- 查询金额在4000 ~ 6000之间的商品信息 SELECT*FROMproductWHEREprice>=4000ANDprice&lt;=6000;SELECT*FROMproductWHEREpriceBETWEEN4000AND6000;-- 查询库存为14、30、23的商品信息 SELECT*FROMproductWHEREstock=14ORstock=30ORstock=23;SELECT*FROMproductWHEREstockIN(14,30,23);-- 查询库存为null的商品信息 SELECT*FROMproductWHEREstockISNULL;-- 查询库存不为null的商品信息 SELECT*FROMproductWHEREstockISNOTNULL;-- 查询名称以小米为开头的商品信息 SELECT*FROMproductWHERENAMELIKE'小米%';-- 查询名称第二个字是为的商品信息 SELECT*FROMproductWHERENAMELIKE'_为%';-- 查询名称为四个字符的商品信息 SELECT*FROMproductWHERENAMELIKE'____';-- 查询名称中包含电脑的商品信息 SELECT*FROMproductWHERENAMELIKE'%电脑%'; 聚合函数
将一列数据作为一个整体，进行纵向的计算 聚合函数分类 函数名 功能 count(列名) 统计数量(一般选用不为null的列) max(列名) 最大值 min(列名) 最小值 sum(列名) 求和 avg(列名) 平均值 聚合函数语法 -- 标准语法 SELECT函数名(列名)FROM表名[WHERE条件];-- 计算product表中总记录条数 SELECTCOUNT(*)FROMproduct;-- 获取最高价格 SELECTMAX(price)FROMproduct;-- 获取最高价格的商品名称 SELECTNAME,priceFROMproductWHEREprice=(SELECTMAX(price)FROMproduct);-- 获取最低库存 SELECTMIN(stock)FROMproduct;-- 获取最低库存的商品名称 SELECTNAME,stockFROMproductWHEREstock=(SELECTMIN(stock)FROMproduct);-- 获取总库存数量 SELECTSUM(stock)FROMproduct;-- 获取品牌为苹果的总库存数量 SELECTSUM(stock)FROMproductWHEREbrand='苹果';-- 获取品牌为小米的平均商品价格 SELECTAVG(price)FROMproductWHEREbrand='小米'; 排序查询
排序分类 注意：多个排序条件，当前边的条件值一样时，才会判断第二条件 关键词 功能 ORDER BY 列名1 排序方式1,列名2 排序方式2 对指定列排序，ASC升序(默认的) DESC降序 排序语法 -- 标准语法 SELECT列名FROM表名[WHERE条件]ORDERBY列名1排序方式1,列名2排序方式2;-- 按照库存升序排序 SELECT*FROMproductORDERBYstockASC;-- 查询名称中包含手机的商品信息。按照金额降序排序 SELECT*FROMproductWHERENAMELIKE'%手机%'ORDERBYpriceDESC;-- 按照金额升序排序，如果金额相同，按照库存降序排列 SELECT*FROMproductORDERBYpriceASC,stockDESC; 分组查询
-- 标准语法 SELECT列名FROM表名[WHERE条件]GROUPBY分组列名[HAVING分组后条件过滤][ORDERBY排序列名排序方式];-- 按照品牌分组，获取每组商品的总金额 SELECTbrand,SUM(price)FROMproductGROUPBYbrand;-- 对金额大于4000元的商品，按照品牌分组,获取每组商品的总金额 SELECTbrand,SUM(price)FROMproductWHEREprice>4000GROUPBYbrand;-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的 SELECTbrand,SUM(price)ASgetSumFROMproductWHEREprice>4000GROUPBYbrandHAVINGgetSum>7000;-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的、并按照总金额的降序排列 SELECTbrand,SUM(price)ASgetSumFROMproductWHEREprice>4000GROUPBYbrandHAVINGgetSum>7000ORDERBYgetSumDESC; 分页查询 -- 标准语法 SELECT列名FROM表名[WHERE条件]GROUPBY分组列名[HAVING分组后条件过滤][ORDERBY排序列名排序方式]LIMIT开始索引,查询条数;-- 公式：开始索引 = (当前页码-1) * 每页显示的条数 -- 每页显示2条数据 SELECT*FROMproductLIMIT0,2;-- 第一页 开始索引=(1-1) * 2 SELECT*FROMproductLIMIT2,2;-- 第二页 开始索引=(2-1) * 2 SELECT*FROMproductLIMIT4,2;-- 第三页 开始索引=(3-1) * 2 SELECT*FROMproductLIMIT6,2;-- 第四页 开始索引=(4-1) * 2 分页查询图解 三、约束 1.约束的概念和分类 约束的概念 对表中的数据进行限定，保证数据的正确性、有效性、完整性！ 约束的分类 约束 说明 PRIMARY KEY 主键约束 PRIMARY KEY AUTO_INCREMENT 主键、自动增长 UNIQUE 唯一约束 NOT NULL 非空约束 FOREIGN KEY 外键约束 FOREIGN KEY ON UPDATE CASCADE 外键级联更新 FOREIGN KEY ON DELETE CASCADE 外键级联删除 2.主键约束 主键约束特点 主键约束包含：非空和唯一两个功能 一张表只能有一个列作为主键 主键一般用于表中数据的唯一标识 建表时添加主键约束 -- 标准语法 CREATETABLE表名(列名数据类型PRIMARYKEY,列名数据类型,...);-- 创建student表 CREATETABLEstudent(idINTPRIMARYKEY-- 给id添加主键约束 );-- 添加数据 INSERTINTOstudentVALUES(1),(2);-- 主键默认唯一，添加重复数据，会报错 INSERTINTOstudentVALUES(2);-- 主键默认非空，不能添加null的数据 INSERTINTOstudentVALUES(NULL);-- 查询student表 SELECT*FROMstudent;-- 查询student表详细 DESCstudent; 删除主键 -- 标准语法 ALTERTABLE表名DROPPRIMARYKEY;-- 删除主键 ALTERTABLEstudentDROPPRIMARYKEY; 建表后单独添加主键 -- 标准语法 ALTERTABLE表名MODIFY列名数据类型PRIMARYKEY;-- 添加主键 ALTERTABLEstudentMODIFYidINTPRIMARYKEY;3.主键自动增长约束 建表时添加主键自增约束 -- 标准语法 CREATETABLE表名(列名数据类型PRIMARYKEYAUTO_INCREMENT,列名数据类型,...);-- 创建student2表 CREATETABLEstudent2(idINTPRIMARYKEYAUTO_INCREMENT-- 给id添加主键自增约束 );-- 添加数据 INSERTINTOstudent2VALUES(1),(2);-- 添加null值，会自动增长 INSERTINTOstudent2VALUES(NULL),(NULL);-- 查询student2表 SELECT*FROMstudent2;-- student2表详细 DESCstudent2; 删除自动增长 -- 标准语法 ALTERTABLE表名MODIFY列名数据类型;-- 删除自动增长 ALTERTABLEstudent2MODIFYidINT; 建表后单独添加自动增长 -- 标准语法 ALTERTABLE表名MODIFY列名数据类型AUTO_INCREMENT;-- 添加自动增长 ALTERTABLEstudent2MODIFYidINTAUTO_INCREMENT;4.唯一约束 建表时添加唯一约束 -- 标准语法 CREATETABLE表名(列名数据类型UNIQUE,列名数据类型,...);-- 创建student3表 CREATETABLEstudent3(idINTPRIMARYKEYAUTO_INCREMENT,telVARCHAR(20)UNIQUE-- 给tel列添加唯一约束 );-- 添加数据 INSERTINTOstudent3VALUES(NULL,'18888888888'),(NULL,'18666666666');-- 添加重复数据，会报错 INSERTINTOstudent3VALUES(NULL,'18666666666');-- 查询student3数据表 SELECT*FROMstudent3;-- student3表详细 DESCstudent3; 删除唯一约束 -- 标准语法 ALTERTABLE表名DROPINDEX列名;-- 删除唯一约束 ALTERTABLEstudent3DROPINDEXtel; 建表后单独添加唯一约束 -- 标准语法 ALTERTABLE表名MODIFY列名数据类型UNIQUE;-- 添加唯一约束 ALTERTABLEstudent3MODIFYtelVARCHAR(20)UNIQUE;5.非空约束 建表时添加非空约束 -- 标准语法 CREATETABLE表名(列名数据类型NOTNULL,列名数据类型,...);-- 创建student4表 CREATETABLEstudent4(idINTPRIMARYKEYAUTO_INCREMENT,NAMEVARCHAR(20)NOTNULL-- 给name添加非空约束 );-- 添加数据 INSERTINTOstudent4VALUES(NULL,'张三'),(NULL,'李四');-- 添加null值，会报错 INSERTINTOstudent4VALUES(NULL,NULL); 删除非空约束 -- 标准语法 ALTERTABLE表名MODIFY列名数据类型;-- 删除非空约束 ALTERTABLEstudent4MODIFYNAMEVARCHAR(20); 建表后单独添加非空约束
-- 标准语法 ALTERTABLE表名MODIFY列名数据类型NOTNULL;-- 添加非空约束 ALTERTABLEstudent4MODIFYNAMEVARCHAR(20)NOTNULL;</content></entry><entry><title>关于我</title><url>https://zhang4014439175.github.io/about.html</url><categories/><tags/><content type="html"> 我叫张志明，英文名zhang zhiming。 职业：后端攻城师 —— 一个90后程序员，终身学习者。 评价：对技术充满热情，充满学习的动力。—— 只要投入时间去学，没有学不会的东西。 技能：主职业是后端（Java、Python）、运维、大数据的技术栈也有所涉及。 业余：业余时间学习过设计的知识，如果逮住合适的机会，也会培养全方位的技能。 娱乐：爱阅读，但读不进文学名著；军事政治爱好者，跑步锻炼忠实粉丝；喜欢 MMORPG 游戏，但现阶段还是要以赚钱为主，等退休了再玩个痛快。 心态：爱生活、爱阅读、爱学习、爱拼搏、爱大自然。 原则：常怀感恩的心。 社交：一个人走得快，一群人走得远。 理财：人生就像滚雪球，重要的是，找到那条又湿又长的雪道。
一、心路历程 小学时候喜欢玩电脑，刚开始没有电脑的时候喜欢往别人家跑，老妈为了把我拴住于是买了第一台电脑。家里一台电脑经受了我的好多锤炼，主机、宽带处理问题都是自己搞。
高中时候自学很多软件，但是没有专研下去。
上大学前学习艺术，于是填志愿去了视觉传达设计（保底也能去打印店作业）。但是对计算机有浓厚的兴趣，因此利用课余时间自学 Java 技术栈。
大三实习期间走出校门，转型到了 IT 行业。在老家山西干了一年Java，开始主做前端。前端能及时给出视觉反馈的特点，成了我热衷这个岗位的最大原因。
有着去大厂的梦想，不过条条大路通罗马，大厂是一条路但不是唯一的路，因而充实好自己最重要，有机会就努力抓住机会，没有机会就自己创造机会。
我是一个普通的程序员，一个平凡的 90 后，但我不想让自己的人生平庸，奥力给！
更多信息请访问我的博客。</content></entry><entry><title>Markdown语法手册</title><url>https://zhang4014439175.github.io/post/markdown-syntax/</url><categories><category>themes</category><category>syntax</category></categories><tags><tag>markdown</tag><tag>css</tag><tag>html</tag></tags><content type="html"> 本文提供了一个可以在 Hugo 内容文件中使用的基本Markdown语法示例，还展示了基本 HTML 元素在 Hugo 主题中是否使用 CSS 装饰。
标题 下面的 HTML 代码&lt;h1>—&lt;h6> 元素表示六个级别的节标题。 &lt;h1>是最高的节级别，&lt;h6>是最低的节级别。
H1 H2 H3 H4 H5 H6 段落 Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.
伊塔图？厨房里有很多东西，我不知道他们喜欢吃什么，或者他们喜欢吃什么。
引用 blockquote元素表示从另一个来源引用的内容，可选的引用必须在footer或cite元素内，也可选的内嵌更改，如注释和缩写。
引用没有归属 Tiam, ad mint andaepu dandae nostion secatur sequo quae. 注意 可以在块引用中使用 Markdown 语法。
带归属的引用 不要通过分享记忆来交流，通过交流来分享记忆。
— 罗布·派克1
表格 表不是Markdown核心规范的一部分，但是Hugo支持开箱即用。
Name Age Bob 27 Alice 23 表格内使用Markdown语法 Italics Bold Code italics bold code 图像 ![图像描述](图像地址) 示例 Google Chrome Firefox Browser
点击图像可以打开图像浏览器，快试试吧。
代码块 带有引号的代码块 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 用四个空格缩进的代码块 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 代码块引用Hugo的内部高亮短代码 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 列表类型 有序列表 First item Second item Third item 无序列表 List item Another item And another item 嵌套列表 Fruit Apple Orange Banana Dairy Milk Cheese 其他元素 — abbr, sub, sup, kbd, mark GIF 是位图图像格式。
H2O
Xn + Yn = Zn
按 CTRL+ALT+Delete 组合键结束会话。
大多数蝾螈在夜间活动，捕食昆虫、蠕虫和其他小动物。
以上引文摘自Rob Pike在2015年11月18日Gopherfest上的演讲。&#160;&#8617;&#xfe0e;</content></entry><entry><title>占位符文本显示</title><url>https://zhang4014439175.github.io/post/placeholder-text/</url><categories/><tags><tag>markdown</tag><tag>text</tag></tags><content type="html"> 你对我的心有偏见。我向您保证，我们的生活将不会受到影响，我们的生活将会受到影响。你说你现在住在医院里，因为你的眼睛是透明的，你的眼睛是光明的，你的眼睛是光明的!
Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.
Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt
The Van de Graaf Canon
Mane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.
Iubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.
Eurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.</content></entry><entry><title>数据公式设置显示</title><url>https://zhang4014439175.github.io/post/math-typesetting/</url><categories/><tags/><content type="html"> Hugo项目中的数学表示法可以通过使用第三方JavaScript库来实现。
在这个例子中，我们将使用 MathJax
Create a post under /content/en[zh-CN]/math.md
可以全局启用MathJax，请在项目配置中将参数math设置为true
或是在每页基础上启用MathJax，在内容文件中包括参数math: true
注意： 使用支持的TeX功能的联机参考资料
例子 重复的分数 $$ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} \equiv 1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}} {1+\frac{e^{-8\pi}} {1+\cdots} } } } $$
总和记号 $$ \left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right) $$
几何级数之和 我把接下来的两个例子分成了几行，这样它在手机上表现得更好。这就是为什么它们包含 \displaystyle。
$$ \displaystyle\sum_{i=1}^{k+1}i $$
$$ \displaystyle= \left(\sum_{i=1}^{k}i\right) +(k+1) $$
$$ \displaystyle= \frac{k(k+1)}{2}+k+1 $$
$$ \displaystyle= \frac{k(k+1)+2(k+1)}{2} $$
$$ \displaystyle= \frac{(k+1)(k+2)}{2} $$
$$ \displaystyle= \frac{(k+1)((k+1)+1)}{2} $$
乘记号 $$ \displaystyle 1 + \frac{q^2}{(1-q)}+\frac{q^6}{(1-q)(1-q^2)}+\cdots = \displaystyle \prod_{j=0}^{\infty}\frac{1}{(1-q^{5j+2})(1-q^{5j+3})}, \displaystyle\text{ for }\lvert q\rvert &lt; 1. $$
随文数式 这是一些线性数学: $$ k_{n+1} = n^2 + k_n^2 - k_{n-1} $$ ， 然后是更多的文本。
希腊字母 $$ \Gamma\ \Delta\ \Theta\ \Lambda\ \Xi\ \Pi\ \Sigma\ \Upsilon\ \Phi\ \Psi\ \Omega \alpha\ \beta\ \gamma\ \delta\ \epsilon\ \zeta\ \eta\ \theta\ \iota\ \kappa\ \lambda\ \mu\ \nu\ \xi \ \omicron\ \pi\ \rho\ \sigma\ \tau\ \upsilon\ \phi\ \chi\ \psi\ \omega\ \varepsilon\ \vartheta\ \varpi\ \varrho\ \varsigma\ \varphi $$
箭头 $$ \gets\ \to\ \leftarrow\ \rightarrow\ \uparrow\ \Uparrow\ \downarrow\ \Downarrow\ \updownarrow\ \Updownarrow $$
$$ \Leftarrow\ \Rightarrow\ \leftrightarrow\ \Leftrightarrow\ \mapsto\ \hookleftarrow \leftharpoonup\ \leftharpoondown\ \rightleftharpoons\ \longleftarrow\ \Longleftarrow\ \longrightarrow $$
$$ \Longrightarrow\ \longleftrightarrow\ \Longleftrightarrow\ \longmapsto\ \hookrightarrow\ \rightharpoonup $$
$$ \rightharpoondown\ \leadsto\ \nearrow\ \searrow\ \swarrow\ \nwarrow $$
符号 $$ \surd\ \barwedge\ \veebar\ \odot\ \oplus\ \otimes\ \oslash\ \circledcirc\ \boxdot\ \bigtriangleup $$
$$ \bigtriangledown\ \dagger\ \diamond\ \star\ \triangleleft\ \triangleright\ \angle\ \infty\ \prime\ \triangle $$
微积分学 $$ \int u \frac{dv}{dx},dx=uv-\int \frac{du}{dx}v,dx $$
$$ f(x) = \int_{-\infty}^\infty \hat f(\xi),e^{2 \pi i \xi x} $$
$$ \oint \vec{F} \cdot d\vec{s}=0 $$
洛伦茨方程 $$ \begin{aligned} \dot{x} &amp; = \sigma(y-x) \ \dot{y} &amp; = \rho x - y - xz \ \dot{z} &amp; = -\beta z + xy \end{aligned} $$
交叉乘积 这在KaTeX中是可行的，但在这种环境中馏分的分离不是很好。
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
这里有一个解决方案:使用“mfrac”类(在MathJax情况下没有区别)的额外类使分数更小:
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
强调 $$ \hat{x}\ \vec{x}\ \ddot{x} $$
有弹性的括号 $$ \left(\frac{x^2}{y^3}\right) $$
评估范围 $$ \left.\frac{x^3}{3}\right|_0^1 $$
诊断标准 $$ f(n) = \begin{cases} \frac{n}{2}, &amp; \text{if } n\text{ is even} \ 3n+1, &amp; \text{if } n\text{ is odd} \end{cases} $$
麦克斯韦方程组 $$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \ \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \ \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \ \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
这些方程式很狭窄。我们可以使用(例如)添加垂直间距 [1em] 在每个换行符(\)之后。正如你在这里看到的：
$$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \[1em] \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \[0.5em] \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \[1em] \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
统计学 固定词组：
$$ \frac{n!}{k!(n-k)!} = {^n}C_k {n \choose k} $$
分数在分数 $$ \frac{\frac{1}{x}+\frac{1}{y}}{y-z} $$
ｎ次方根 $$ \sqrt[n]{1+x+x^2+x^3+\ldots} $$
矩阵 $$ \begin{pmatrix} a_{11} &amp; a_{12} &amp; a_{13}\ a_{21} &amp; a_{22} &amp; a_{23}\ a_{31} &amp; a_{32} &amp; a_{33} \end{pmatrix} \begin{bmatrix} 0 &amp; \cdots &amp; 0 \ \vdots &amp; \ddots &amp; \vdots \ 0 &amp; \cdots &amp; 0 \end{bmatrix} $$
标点符号 $$ f(x) = \sqrt{1+x} \quad (x \ge -1) f(x) \sim x^2 \quad (x\to\infty) $$
现在用标点符号:
$$ f(x) = \sqrt{1+x}, \quad x \ge -1 f(x) \sim x^2, \quad x\to\infty $$</content></entry><entry><title>支持Emoji表情符号</title><url>https://zhang4014439175.github.io/post/emoji-support/</url><categories/><tags><tag>emoji</tag></tags><content type="html"> 在Hugo项目中可以通过多种方式启用Emoji。
The emojify function can be called directly in templates or Inline Shortcodes.
To enable emoji globally, set enableEmoji to true in your site&rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.
馃檲 🙈 馃檳 🙉 馃檴 🙊
The Emoji cheat sheet is a useful reference for emoji shorthand codes.
N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.
.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }</content></entry></search>