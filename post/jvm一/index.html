<!doctype html><html lang=zh-cn dir=content/zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>Java进阶-JVM（一） - 换个方向前进</title><meta name=keywords content="博客,程序员,架构师,思考,读书,笔记,技术,分享,大数据,产品"><meta name=author content="换个方向前进"><meta property="og:title" content="Java进阶-JVM（一）"><meta property="og:site_name" content="换个方向前进"><meta property="og:image" content="https://zhang4014439175.github.io/img/author.jpg"><meta name=title content="Java进阶-JVM（一） - 换个方向前进"><meta name=description content="Sample article showcasing basic String syntax."><link rel="shortcut icon" href=https://zhang4014439175.github.io/img/favicon.ico><link rel=apple-touch-icon href=https://zhang4014439175.github.io/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=https://zhang4014439175.github.io/img/apple-touch-icon.png><link href=//unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.css rel=stylesheet><link href=https://zhang4014439175.github.io/css/main.css rel=stylesheet type=text/css><link href=https://zhang4014439175.github.io/css/syntax.css rel=stylesheet type=text/css></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span>
<span class=site-title>换个方向前进</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>愿每个目标坚定的自己，都能在未来无惧内卷、自信昂扬!</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-active"><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>分类</a></li><li class=menu-item><a href=/about.html rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于我的</a></li><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益网站</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span>
<span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://zhang4014439175.github.io/post/jvm%E4%B8%80/ itemprop=url>Java进阶-JVM（一）</a></h1><div class=post-meta><span class=post-pushdate><i class="fa fa-calendar-o fa-fw"></i>
<span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22 content="2021-12-15">2021-12-15</time></span>
<span class=post-category><i class="fa fa-folder-o fa-fw"></i>
<span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a class=post-category-a href=/categories/java-advanced itemprop=url rel=index><span itemprop=name>Java-Advanced</span></a>
&nbsp;</span></span>
<span class=post-wordcount><i class="fa fa-file-word-o fa-fw"></i>
<span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>7429 字</span></span>
<span class=post-readtime><i class="fa fa-eye fa-fw"></i>
<span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>15分钟</span></span>
<span id=/post/jvm%E4%B8%80/ class="leancloud_visitors post-visitor" data-flag-title=Java进阶-JVM（一）><i class="fa fa-binoculars fa-fw"></i>
<span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><p>        JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。
        引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p><h1 id=一内存结构>一、内存结构</h1><p><img src=https://camo.githubusercontent.com/0ce601775df93b95a54d856a524930e950ca54f91c908fdf78284f9b9430b9c2/68747470733a2f2f63646e2d646f6f63732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f67682f646f6f63732f6a766d406d61696e2f696d616765732f6a766d2d6d656d6f72792d7374727563747572652e6a7067 alt></p><h2 id=1程序计数器>1、程序计数器</h2><h3 id=11定义>1.1、定义</h3><p>程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为<code>Undefined</code>。</p><h3 id=12作用>1.2、作用</h3><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。</li><li>在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。</li></ul><h3 id=13特点>1.3、特点</h3><ul><li>是一块较小的内存空间。</li><li>线程私有，每条线程都有自己的程序计数器。</li><li>生命周期：随着线程的创建而创建，随着线程的结束而销毁。</li><li>是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域。</li></ul><h2 id=2java虚拟机栈>2、java虚拟机栈</h2><p>Java 虚拟机栈是描述 Java 方法运行过程的内存模型。</p><p>Java 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：</p><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法出口信息</li></ul><p><strong>压栈出栈过程：</strong></p><p>当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。</p><p>Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。</p><p>方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。</p><h3 id=21局部变量表>2.1、局部变量表</h3><p>1）局部变量表也被称为<strong>局部变量数组</strong>或者<strong>本地变量表</strong></p><p>2）关于slot的理解</p><ul><li><p>局部变量表中最基础的存储单元为slot（变量槽）</p></li><li><p>在局部变量表中，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</p></li><li><p>byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。</p></li><li><p>long和double则占据两个slot。</p></li><li><p>当前帧的构造方法或者实例方法创建时，那么该对象引用this将会存放在index为0的slot处（下面的jclasslib会有体现），其余的参数按照参数表顺序继续排序。</p></li></ul><p>3）局部变量表</p><ul><li>因为局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据的安全问题。</li><li>局部变量表所需的容量大小是在编译期确定下来的。保存在Code属性的maximum local variables数据项中，在这个方法运行期间不会改变局部变量的大小。</li><li>方法嵌套的次数由栈的大小决定。</li><li>局部变量表中的变量只能在当前方法调用中有效。当方法调用结束时，随着方法栈帧的销毁，局部变量表也会随之销毁。</li><li>局部变量表中的变量是重要的垃圾回收节点，只要被局部变量表中直接或者间接引用的对象都不会被回收（垃圾回收中的根搜索算法，在JAVA中都是使用这种算法进行垃圾回收），局部变量表中的变量若不存在，则指向堆空间的指针消失，顾堆空间中的垃圾被回收。</li></ul><h3 id=22操作数栈>2.2、操作数栈</h3><ul><li><strong>栈顶缓存技术</strong>：由于操作数是存储在内存中，频繁的进行内存读写操作影响执行速度，将栈顶元素全部缓存到物理 CPU 的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。</li><li>每一个操作数栈会拥有一个明确的栈深度，用于存储数值，最大深度在编译期就定义好。32bit 类型占用一个栈单位深度，64bit 类型占用两个栈单位深度操作数栈。</li><li>并非采用访问索引方式进行数据访问，而是只能通过标准的入栈、出栈操作完成一次数据访问。</li></ul><h3 id=23方法的调用>2.3、方法的调用</h3><ul><li>静态链接：当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行时期间保持不变，这种情况下降调用方的符号引用转为直接引用的过程称为静态链接。</li><li>动态链接：如果被调用的方法无法在编译期被确定下来，只能在运行期将调用的方法的符号引用转为直接引用，这种引用转换过程具备动态性，因此被称为动态链接。</li><li>方法绑定<ul><li>早期绑定：被调用的目标方法如果在编译期可知，且运行期保持不变。</li><li>晚期绑定：被调用的方法在编译期无法被确定，只能够在程序运行期根据实际的类型绑定相关的方法。</li></ul></li><li>非虚方法：如果方法在编译期就确定了具体的调用版本，则这个版本在运行时是不可变的，这样的方法称为非虚方法静态方法。私有方法，final 方法，实例构造器，父类方法都是非虚方法，除了这些以外都是虚方法。</li><li>虚方法表：面向对象的编程中，会很频繁的使用动态分配，如果每次动态分配的过程都要重新在类的方法元数据中搜索合适的目标的话，就可能影响到执行效率，因此为了提高性能，JVM 采用在类的方法区建立一个虚方法表，使用索引表来代替查找。<ul><li>每个类都有一个虚方法表，表中存放着各个方法的实际入口。</li><li>虚方法表会在类加载的链接阶段被创建，并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法也初始化完毕。</li></ul></li><li>方法重写的本质<ul><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记做 C。如果在类型 C 中找到与常量池中描述符和简单名称都相符的方法，则进行访问权限校验。</li><li>如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常。</li><li>否则，按照继承关系从下往上依次对 C 的各个父类进行上一步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常。</li></ul></li></ul><p>Java 中任何一个普通方法都具备虚函数的特征（运行期确认，具备晚期绑定的特点），C++ 中则使用关键字 virtual 来显式定义。如果在 Java 程序中，不希望某个方法拥有虚函数的特征，则可以使用关键字 final 来标记这个方法。</p><h3 id=24本地方法栈c-栈>2.4、本地方法栈（C 栈）</h3><p><strong>本地方法栈的定义：</strong></p><p>本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。</p><p><strong>栈帧变化过程：</strong></p><p>本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。</p><p>方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。</p><blockquote><p>如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。</p></blockquote><h3 id=25堆>2.5、堆</h3><p><strong>堆的定义：</strong></p><p>堆是用来存放对象的内存空间，<code>几乎</code>所有的对象都存储在堆中。</p><p><strong>堆的特点：</strong></p><ul><li>线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。</li><li>在虚拟机启动时创建。</li><li>是垃圾回收的主要场所。</li><li>堆可分为新生代（Eden 区：<code>From Survior</code>，<code>To Survivor</code>）、老年代。</li><li>Java 虚拟机规范规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</li><li>关于 Survivor s0，s1 区: 复制之后有交换，谁空谁是 to。</li></ul><p>不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。</p><p>堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。</p><blockquote><p>Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。</p></blockquote><p><strong>新生代与老年代：</strong></p><ul><li>老年代比新生代生命周期长。</li><li>新生代与老年代空间默认比例 <code>1:2</code>：JVM 调参数，<code>XX:NewRatio=2</code>，表示新生代占 1，老年代占 2，新生代占整个堆的 1/3。</li><li>HotSpot 中，Eden 空间和另外两个 Survivor 空间缺省所占的比例是：<code>8:1:1</code>。</li><li>几乎所有的 Java 对象都是在 Eden 区被 new 出来的，Eden 放不了的大对象，就直接进入老年代了。</li></ul><p><strong>对象分配过程：</strong></p><ul><li>new 的对象先放在 Eden 区，大小有限制</li><li>如果创建新对象时，Eden 空间填满了，就会触发 Minor GC，将 Eden 不再被其他对象引用的对象进行销毁，再加载新的对象放到 Eden 区，特别注意的是 Survivor 区满了是不会触发 Minor GC 的，而是 Eden 空间填满了，Minor GC 才顺便清理 Survivor 区</li><li>将 Eden 中剩余的对象移到 Survivor0 区</li><li>再次触发垃圾回收，此时上次 Survivor 下来的，放在 Survivor0 区的，如果没有回收，就会放到 Survivor1 区</li><li>再次经历垃圾回收，又会将幸存者重新放回 Survivor0 区，依次类推</li><li>默认是 15 次的循环，超过 15 次，则会将幸存者区幸存下来的转去老年区 jvm 参数设置次数 : -XX:MaxTenuringThreshold=N 进行设置</li><li>频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间搜集</li></ul><p><strong>Full GC /Major GC 触发条件：</strong></p><ul><li>显示调用<code>System.gc()</code>，老年代的空间不够，方法区的空间不够等都会触发 Full GC，同时对新生代和老年代回收，FUll GC 的 STW 的时间最长，应该要避免</li><li>在出现 Major GC 之前，会先触发 Minor GC，如果老年代的空间还是不够就会触发 Major GC，STW 的时间长于 Minor GC</li></ul><h3 id=26堆-逃逸分析>2.6、堆-逃逸分析</h3><ul><li><strong>对象和数组并非都是在堆上分配内存的</strong></li><li>《深入理解 Java 虚拟机中》关于 Java 堆内存有这样一段描述：随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，<code>栈上分配</code>,<code>标量替换</code>优化技术将会导致一些变化，所有的对象都分配到堆上也渐渐变得不那么"绝对"了。</li><li>这是一种可以有效减少 Java 内存堆分配压力的分析算法，通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li><li>当一个对象在方法中被定义后，它可能被外部方法所引用，如作为调用参数传递到其他地方中，称为<code>方法逃逸</code>。</li><li>再如赋值给类变量或可以在其他线程中访问的实例变量，称为<code>线程逃逸</code></li><li>使用逃逸分析，编译器可以对代码做如下优化：<ul><li>同步省略：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li>将堆分配转化为栈分配：如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</li><li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中。</li></ul></li></ul><p>**方法逃逸：**对象逃出当前方法</p><p>对象在方法里面被定义后，它可能被外部方法所引用，如：</p><p>对象作为方法的返回值或对象的引用包含在返回值中</p><p>对象作为方法参数传递或者被参数引用</p><p>**线程逃逸：**对象逃出当前线程</p><p>对象可能被其它线程访问到</p><p>对象是一个静态变量</p><p>对象是一个可以在其它线程中访问的实例变量</p><h4 id=261标量替换>2.6.1标量替换：</h4><ul><li>标量不可在分解的量，java 的基本数据类型就是标量，标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在 JAVA 中对象就是可以被进一步分解的聚合量</li><li>替换过程，通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。</li></ul><p>如果对象不会逃逸，分配到栈内存的时候，会进行标量替换。</p><p>栈中直接分配对象难度太大，需要修改JVM中大量堆优先分配的代码，因此在HotSpot中并没有真正的实现栈中分配对象的功能，取而代之的是一个叫做标量替换的折中办法。</p><p><strong>标量和聚合量：</strong></p><p>**标量：**基础类型和对象的引用可以理解为标量，它们不能被进一步分解
**聚合量：**能被进一步分解的量就是聚合量，对象就是聚合量，它可以被进一步分解成标量
将对象的成员变量分解为分散的标量，这就叫做标量替换。</p><p>这样，如果一个对象没有发生逃逸，那压根就不需要在"堆"中创建它，只会在栈或者寄存器上创建一些能够映射这个对象标量即可，节省了内存空间，也提升了应用程序性能。</p><h4 id=262锁消除>2.6.2锁消除：</h4><ul><li><p><strong>如果对象不会逃逸，这个对象就永远不会被其它方法或者线程访问到。</strong></p></li><li><p>这时对象锁synchronized(object) 没有任何意义（因为在任何线程中，object都是不同的锁对象）。所以JVM会对上述代码进行优化，删除锁。</p></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>public</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>lockEliminate</span><span style=color:#666>()</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    User user <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> User<span style=color:#666>();</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>synchronized</span> <span style=color:#666>(</span>user<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;执行同步代码块&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>在lockEliminate() 方法中，对象user永远不会被其它方法或者线程访问到，因此user是不会逃逸对象，这就导致synchronized(user) 没有任何意义，因为在任何线程中，user都是不同的锁对象。</p><p>所以JVM会对上述代码进行优化，删除同步相关代码，如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>public</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>lockEliminate</span><span style=color:#666>()</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    User user <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> User<span style=color:#666>();</span>
</span></span><span style=display:flex><span>    System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;执行同步代码块&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p><strong>常见的锁消除场景：StringBuffer</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>public</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>lockEliminate</span><span style=color:#666>()</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    StringBuffer stringBuffer <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> StringBuffer<span style=color:#666>();</span>
</span></span><span style=display:flex><span>    stringBuffer<span style=color:#666>.</span><span style=color:#b44>append</span><span style=color:#666>(</span><span style=color:#b44>&#34;1&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>    stringBuffer<span style=color:#666>.</span><span style=color:#b44>append</span><span style=color:#666>(</span><span style=color:#b44>&#34;2&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>    System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span>stringBuffer<span style=color:#666>.</span><span style=color:#b44>toString</span><span style=color:#666>());</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>此时append方法上的synchronized锁会被消除</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f>@Override</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>synchronized</span> StringBuffer <span style=color:#00a000>append</span><span style=color:#666>(</span>String str<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    toStringCache <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>super</span><span style=color:#666>.</span><span style=color:#b44>append</span><span style=color:#666>(</span>str<span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>this</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>//实际等同于
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span style=color:#a2f>@Override</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>public</span> StringBuffer <span style=color:#00a000>append</span><span style=color:#666>(</span>String str<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    toStringCache <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>super</span><span style=color:#666>.</span><span style=color:#b44>append</span><span style=color:#666>(</span>str<span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>this</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><h4 id=263栈上分配>2.6.3栈上分配：</h4><p>如果对象不会逃逸，那么这个对象可能会被分配在栈内存上而非常见的堆内存上（对象分配消除）。</p><p>对象分配消除：是指将本该在"堆"中分配的对象，转化为由"栈"中分配。</p><p>上面为什么说的是可能呢？</p><p>因为Hotspot中采用的是解释器和编译器并行的架构，所谓的混合模式就是解释器和编译器搭配使用。</p><ul><li>当程序启动初期，采用解释器执行（同时会记录相关的数据，比如函数的调用次数，循环语句执行次数），节省编译的时间。</li><li>在使用解释器执行期间，记录的函数运行的数据，通过这些数据发现某些代码是热点代码，采用编译器对热点代码进行编译，以及优化（逃逸分析就是其中一种优化技术）。</li></ul><p>所以逃逸分析只在编译器进行编译才会有。</p><h3 id=27堆-本地分配缓存区>2.7、堆-本地分配缓存区</h3><ul><li>TLAB 的全称是 Thread Local Allocation Buffer，即线程本地分配缓存区，是属于 Eden 区的，这是一个线程专用的内存分配区域，线程私有，默认开启的（当然也不是绝对的，也要看哪种类型的虚拟机）</li><li>堆是全局共享的，在同一时间，可能会有多个线程在堆上申请空间，但每次的对象分配需要同步的进行（虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性）但是效率却有点下降</li><li>所以用 TLAB 来避免多线程冲突，在给对象分配内存时，每个线程使用自己的 TLAB，这样可以使得线程同步，提高了对象分配的效率</li><li>当然并不是所有的对象都可以在 TLAB 中分配内存成功，如果失败了就会使用加锁的机制来保持操作的原子性</li><li><code>-XX:+UseTLAB </code>使用 TLAB，<code>-XX:+TLABSize</code> 设置 TLAB 大小</li></ul><h3 id=28堆-四种引用方式>2.8、堆-四种引用方式</h3><ul><li>**强引用：**创建一个对象并把这个对象赋给一个引用变量，普通 new 出来对象的变量引用都是强引用，有引用变量指向时永远不会被垃圾回收，jvm 即使抛出 OOM，可以将引用赋值为 null，那么它所指向的对象就会被垃圾回收。</li><li>**软引用：**如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。</li><li>**弱引用：**非必需对象，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。</li><li>**虚引用：**虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</li></ul><h3 id=29方法区>2.9、方法区</h3><p><strong>方法区的定义：</strong></p><p>Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：</p><ul><li>已经被虚拟机加载的类信息</li><li>常量</li><li>静态变量</li><li>即时编译器编译后的代码</li></ul><p><strong>方法区的特点：</strong></p><ul><li>线程共享。 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。</li><li>永久代。 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。</li><li>内存回收效率低。 方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。</li><li>Java 虚拟机规范对方法区的要求比较宽松。 和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。</li></ul><p><strong>运行时常量池：</strong></p><p>方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。</p><p>当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 <code>intern()</code> 方法就能在运行期间向常量池中添加字符串常量。</p><h3 id=210直接内存堆外内存>2.10、直接内存（堆外内存）</h3><p>直接内存是除 Java 虚拟机之外的内存，但也可能被 Java 使用。</p><p><strong>操作直接内存：</strong></p><p>在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的<code>DirectByteBuffer</code>对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。</p><p>直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。</p><p><strong>直接内存与堆内存比较：</strong></p><ul><li>直接内存申请空间耗费更高的性能</li><li>直接内存读取 IO 的性能要优于普通的堆内存</li><li>直接内存作用链： 本地 IO -> 直接内存 -> 本地 IO</li><li>堆内存作用链：本地 IO -> 直接内存 -> 非直接内存 -> 直接内存 -> 本地 IO</li></ul><blockquote><p>服务器管理员在配置虚拟机参数时，会根据实际内存设置<code>-Xmx</code>等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现<code>OutOfMemoryError</code>异常。</p></blockquote><h3 id=211java-虚拟机栈的特点>2.11、Java 虚拟机栈的特点</h3><ul><li>运行速度特别快，仅仅次于 PC 寄存器。</li><li>局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。</li><li>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。<ul><li>StackOverFlowError 若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。</li><li>OutOfMemoryError 若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。</li></ul></li><li>Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。</li><li>出现 StackOverFlowError 时，内存空间可能还有很多。</li></ul><p>常见的运行时异常有：</p><ul><li>NullPointerException - 空指针引用异常</li><li>ClassCastException - 类型强制转换异</li><li>IllegalArgumentException - 传递非法参数异常</li><li>ArithmeticException - 算术运算异常</li><li>ArrayStoreException - 向数组中存放与声明类型不兼容对象异常</li><li>IndexOutOfBoundsException - 下标越界异常</li><li>NegativeArraySizeException - 创建一个大小为负数的数组错误异常</li><li>NumberFormatException - 数字格式异常</li><li>SecurityException - 安全异常</li><li>UnsupportedOperationException - 不支持的操作异常</li></ul></div><footer class=post-footer><div class=post-tags><a href=/tags/java rel=tag title=Java>#Java#</a>
<a href=/tags/jvm rel=tag title=JVM>#JVM#</a>
<a href=/tags/%e5%86%85%e5%ad%98 rel=tag title=内存>#内存#</a>
<a href=/tags/%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6 rel=tag title=垃圾回收>#垃圾回收#</a></div><div class=addthis_inline_share_toolbox></div><div class=post-nav><div class=article-copyright><div class=article-copyright-img><img src=/img/qq_qrcode.png width=129px height=129px><div style=text-align:center>QQ扫一扫交流</div></div><div class=article-copyright-info><p><span>标题：</span>Java进阶-JVM（一）</p><p><span>链接：</span>https://zhang4014439175.github.io/post/jvm%E4%B8%80/</p><p><span>作者：</span>换个方向前进</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/3.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick='var qr=document.getElementById("QR");qr.style.display==="none"?qr.style.display="block":qr.style.display="none"'>
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://zhang4014439175.github.io/post/jvm%E4%BA%8C/ rel=next title=Java进阶-JVM（二）><i class="fa fa-chevron-left"></i> Java进阶-JVM（二）</a></div><div class="post-nav-prev post-nav-item"><a href=https://zhang4014439175.github.io/post/stream%E6%B5%81/ rel=prev title=Stream流的最全分类和应用>Stream流的最全分类和应用
<i class="fa fa-chevron-right"></i></a></div></div><div id=wcomments></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/img/avatar.png alt=换个方向前进><p class=site-author-name itemprop=name>换个方向前进</p><p class="site-description motion-element" itemprop=description>在我的电脑上是正常的!</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>28</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>33</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href="https://blog.csdn.net/u010837355?type=blog" target=_blank title=CSDN><i class="fa fa-fw fa-globe"></i>
CSDN</a></span>
<span class=links-of-author-item><a href=https://stackoverflow.com/users/17131342/git-zhangzm target=_blank title=StackOverFlow><i class="fa fa-fw fa-globe"></i>
StackOverFlow</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class=links-of-blogroll-title><i class="fa fa-fw fa-globe"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://nutzam.com/ title=Nutz target=_blank>Nutz</a></li><li class=links-of-blogroll-item><a href=https://jfinal.com/ title=JFinal target=_blank>JFinal</a></li><li class=links-of-blogroll-item><a href=http://wendal.net/ title=Wendal target=_blank>Wendal</a></li><li class=links-of-blogroll-item><a href=https://www.liaoxuefeng.com/ title=廖雪峰 target=_blank>廖雪峰</a></li></ul></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>
标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/java>Java
<sup>15</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/spring>Spring
<sup>7</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%A1%86%E6%9E%B6>框架
<sup>7</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/mysql>Mysql
<sup>5</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/sql>SQL
<sup>5</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/docker>Docker
<sup>4</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF>容器化技术
<sup>4</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/jvm>Jvm
<sup>2</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/mybatis>Mybatis
<sup>2</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/rabbitmq>Rabbitmq
<sup>2</sup></a></li></ul></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2010 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=copyright-author>换个方向前进</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.96.0</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span class=site-uv><i class="fa fa-user"></i>
<span class=busuanzi-value id=busuanzi_value_site_uv></span></span>
<span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i>
<span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div><div class=license-info><span class=storage-info>Storage by
<a href=https://www.aliyun.com/ style=font-weight:700 target=_blank>阿里云</a></span>
<span class=separator-line>/</span>
<span class=license-num><a href=http://beian.miit.gov.cn target=_blank>京ICP备2022030480号-1</a></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i>
<span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//unpkg.com/jquery@2.1.4/dist/jquery.min.js></script>
<script type=text/javascript src=https://zhang4014439175.github.io/js/search.js></script>
<script type=text/javascript src=https://zhang4014439175.github.io/js/affix.js></script>
<script type=text/javascript>function detectIE(){var e=window.navigator.userAgent,t=e.indexOf("MSIE "),n=e.indexOf("Trident/"),s=e.indexOf("Edge/");return t>0||n>0||s>0?-1:1}function getCntViewHeight(){var t=$("#content").height(),e=$(window).height(),n=t>e?t-e:$(document).height()-e;return n}function getScrollbarWidth(){var e=$("<div />").addClass("scrollbar-measure").prependTo("body"),t=e[0],n=t.offsetWidth-t.clientWidth;return e.remove(),n}function registerBackTop(){var t=50,e=$(".back-to-top");$(window).on("scroll",function(){e.toggleClass("back-to-top-on",window.pageYOffset>t);var s=$(window).scrollTop(),o=getCntViewHeight(),i=s/o,n=Math.round(i*100),a=n>100?100:n;$("#scrollpercent>span").html(a)}),e.on("click",function(){$("html,body").animate({scrollTop:0,screenLeft:0},800)})}function initScrollSpy(){var e=".post-toc",s=$(e),t=".active-current";s.on("activate.bs.scrollspy",function(){var t=$(e+" .active").last();n(),t.addClass("active-current")}).on("clear.bs.scrollspy",n),$("body").scrollspy({target:e});function n(){$(e+" "+t).removeClass(t.substring(1))}}function initAffix(){var e=$(".header-inner").height(),t=parseInt($(".footer").outerHeight(!0),10),n=e+10;$(".sidebar-inner").affix({offset:{top:n,bottom:t}})}function initTOCDimension(){$(window).on("resize",function(){e&&clearTimeout(e),e=setTimeout(function(){var e=document.body.clientHeight-100;updateTOCHeight(e)},0)}),updateTOCHeight(document.body.clientHeight-100);var e,t=getScrollbarWidth();$(".post-toc").css("width","calc(100% + "+t+"px)")}function updateTOCHeight(e){e=e||"auto",$(".post-toc").css("max-height",e)}$(function(){var t=$(".header-inner").height()+10,n,s,e,o;$("#sidebar").css({'margin-top':t}).show(),n=parseInt($("#sidebar").css("margin-top")),s=parseInt($(".sidebar-inner").css("height")),e=n+s,o=$(".content-wrap").height(),o<e&&$(".content-wrap").css("min-height",e),$(".site-nav-toggle").on("click",function(){var e=$(".site-nav"),o=$(".toggle"),t="site-nav-on",i="toggle-close",n=e.hasClass(t),a=n?"slideUp":"slideDown",s=n?"removeClass":"addClass";e.stop()[a]("normal",function(){e[s](t),o[s](i)})}),registerBackTop(),initAffix(),initTOCDimension(),$(".sidebar-nav-toc").click(function(){$(this).addClass("sidebar-nav-active"),$(this).next().removeClass("sidebar-nav-active"),$("."+$(this).next().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)}),$(".sidebar-nav-overview").click(function(){$(this).addClass("sidebar-nav-active"),$(this).prev().removeClass("sidebar-nav-active"),$("."+$(this).prev().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)})})</script><script src=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.js></script>
<script type=text/javascript>$(function(){$(".post-body").viewer()})</script><script type=text/javascript>const locale={placeholder:"欢迎留下您的宝贵建议，请填写您的昵称和邮箱便于后续交流. ^_^"};$(function(){detectIE()>0?$.getScript(document.location.protocol+"//unpkg.com/@waline/client@1.6.0/dist/Waline.min.js",function(){new Waline({el:"#wcomments",visitor:!0,emoji:[],wordLimit:"200",uploadImage:!1,locale,requiredMeta:["nick","mail"],serverURL:"Your WalineSerURL",lang:"zh-cn"})}):$("#wcomments").html("抱歉，Waline插件不支持IE或Edge，建议使用Chrome浏览器。")})</script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=Your%20AddthisId"></script>
<script>(function(){var e=document.createElement("script"),t,n=window.location.protocol.split(":")[0];n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>