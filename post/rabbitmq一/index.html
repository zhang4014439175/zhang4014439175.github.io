<!doctype html><html lang=zh-cn dir=content/zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>RabbitMQ（一） - 热爱生活与梦想</title><meta name=keywords content="博客,程序员,架构师,思考,读书,笔记,技术,分享,大数据,产品"><meta name=author content="凡梦星尘"><meta property="og:title" content="RabbitMQ（一）"><meta property="og:site_name" content="热爱生活与梦想"><meta property="og:image" content="https://zhang4014439175.github.ioimg/author.jpg"><meta name=title content="RabbitMQ（一） - 热爱生活与梦想"><meta name=description content="Sample article showcasing basic String syntax."><link rel="shortcut icon" href=https://zhang4014439175.github.ioimg/favicon.ico><link rel=apple-touch-icon href=https://zhang4014439175.github.ioimg/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=https://zhang4014439175.github.ioimg/apple-touch-icon.png><link href=//unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.css rel=stylesheet><link href=https://zhang4014439175.github.iocss/main.css rel=stylesheet type=text/css><link href=https://zhang4014439175.github.iocss/syntax.css rel=stylesheet type=text/css></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span>
<span class=site-title>热爱生活与梦想</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>没有伞的孩子要学会努力奔跑!</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-active"><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/about.html rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于我</a></li><li class=menu-item><a href=/404.html rel=section><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span>
<span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://zhang4014439175.github.io/post/rabbitmq%E4%B8%80/ itemprop=url>RabbitMQ（一）</a></h1><div class=post-meta><span class=post-pushdate><i class="fa fa-calendar-o fa-fw"></i>
<span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2022-03-13">2022-03-13</time></span>
<span class=post-category><i class="fa fa-folder-o fa-fw"></i>
<span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a class=post-category-a href=/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1 itemprop=url rel=index><span itemprop=name>微服务</span></a>
&nbsp;</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a class=post-category-a href=/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6 itemprop=url rel=index><span itemprop=name>中间件</span></a>
&nbsp;</span></span>
<span class=post-wordcount><i class="fa fa-file-word-o fa-fw"></i>
<span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>11449 字</span></span>
<span class=post-readtime><i class="fa fa-eye fa-fw"></i>
<span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>23分钟</span></span>
<span id=/post/rabbitmq%E4%B8%80/ class="leancloud_visitors post-visitor" data-flag-title=RabbitMQ（一）><i class="fa fa-binoculars fa-fw"></i>
<span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><h1 id=一简介功能>一、简介功能</h1><h2 id=1简介>1、简介</h2><p>什么是 MQ</p><p>消息队列 尚硅谷</p><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。</p><p>建议使用更优秀的方案；MQ对业务系统侵入性高，使用cdc工具+kafka+flink，延迟低，业务系统0侵入，现在实时数仓都爱用这套，非常好用</p><h2 id=2功能>2、功能</h2><h3 id=1流量消峰>1）流量消峰</h3><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正 常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的。</p><p>只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p><p><strong>好处</strong>：订单系统不宕机</p><p><strong>坏处</strong>：访问比较慢</p><h3 id=2应用解耦>2）应用解耦</h3><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于 消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p><h3 id=3异步处理>3）异步处理</h3><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可 以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此 消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不 用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p><h2 id=3分类>3、分类</h2><p>1.ActiveMQ</p><p>优点:单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据</p><p>缺点:官方社区现在对 ActiveMQ 5.x <strong>维护越来越少，高吞吐量场景较少使用</strong>。 尚硅谷官网视频: <a href=http://www.gulixueyuan.com/course/322 target=_blank rel=noopener>http://www.gulixueyuan.com/course/322</a></p><p>2.Kafka</p><p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为<strong>大数据而生</strong>的消息中间件， 以其<strong>百万级</strong> <strong>TPS</strong> 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</p><p><strong>优点</strong>： 性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是吞<strong>吐量高</strong>。时效性 ms 级可用性非 常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方 Kafka Web 管理界面 Kafka-Manager;在日志领域比较成熟，被多家公司和多个开源项目使用;功能支持: 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及<strong>日志采集</strong>被大规模使用</p><p><strong>缺点</strong>：Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，<strong>社区更新较慢；</strong></p><p>3.RocketMQ</p><p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场 景。</p><p><strong>优点</strong>：<strong>单机吞吐量十万级</strong>，可用性非常高，分布式架构,<strong>消息可以做到</strong> <strong>0</strong> <strong>丢失</strong>**,<strong>MQ 功能较为完善，还是分布式的，扩展性好,支持10亿级别的消息堆积</strong>，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 MQ</p><p>缺点:<strong>支持的客户端语言不多</strong>，目前是 java 及 c++，其中 c++不成熟;社区活跃度一般,没有在 MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码</p><p>4.RabbitMQ</p><p>2007 年发布，是一个在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是<strong>当前最主流的消息中间件之一</strong>。</p><p><strong>优点</strong>：由于 erlang 语言的<strong>高并发特性</strong>，性能较好；<strong>吞吐量到万级</strong>，MQ 功能比较完备,健壮、稳定、易 用、跨平台、<strong>支持多种语言</strong> 如:Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,<strong>社区活跃度高</strong>;更新频率相当高</p><p><a href=https://www.rabbitmq.com/news.html target=_blank rel=noopener>https://www.rabbitmq.com/news.html</a></p><p><strong>缺点</strong>：商业版需要收费,学习成本较高</p><h2 id=4mq-的选择>4、MQ 的选择</h2><p>1.Kafka</p><p>Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集 和传输，适合产生<strong>大量数据</strong>的互联网服务的数据收集业务。<strong>大型公司</strong>建议可以选用，如果有<strong>日志采集</strong>功能， 肯定是首选 kafka 了。尚硅谷官网 kafka 视频连接 <a href=http://www.gulixueyuan.com/course/330/tasks target=_blank rel=noopener>http://www.gulixueyuan.com/course/330/tasks</a></p><p>2.RocketMQ</p><p>天生为<strong>金融互联网</strong>领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削 峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p><p>3.RabbitMQ</p><p>结合 erlang 语言本身的并发优势，性能好<strong>时效性微秒级</strong>，<strong>社区活跃度也比较高</strong>，管理界面用起来十分方便，如果你的<strong>数据量没有那么大</strong>，中小型公司优先选择功能比较完备的 RabbitMQ。</p><h1 id=二rabbitmq>二、RabbitMQ</h1><h2 id=1rabbitmq的概念>1、RabbitMQ的概念</h2><p>RabbitMQ 是一个消息中间件:它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包 裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。</p><h2 id=2四大核心概念>2、四大核心概念</h2><p>1）生产者：</p><p>产生数据发送消息的程序是生产者</p><p>2）交换机：</p><p>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p><p>3）队列：</p><p>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存 储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可 以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p><p>4）消费者：</p><p>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费 者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p><h2 id=3六大核心模式>3、六大核心模式</h2><p>1）hello world简单模式</p><p>2）work queues工作队列</p><p>3）publish/subscribe发布订阅模式</p><p>4）routing路由模式</p><p>5）topics主体模式</p><p>6）publisher confirms发布确认模式</p><h2 id=4工作原理>4、工作原理</h2><p><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p><p><strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似 于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出 多个 vhost，每个用户在自己的 vhost 创建 exchange/queue 等</p><p><strong>Connection</strong>：publisher/consumer 和 broker 之间的 TCP 连接</p><p><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程 序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 <strong>Channel</strong> <strong>极大减少了操作系统建立</strong> <strong>TCP connection</strong> <strong>的开销</strong></p><p><strong>Exchange</strong>：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有:direct (point-to-point), topic (publish-subscribe) and fanout(multicast)</p><p><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走</p><p><strong>Binding</strong>：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据</p><h1 id=三生产者消费者one>三、生产者消费者one</h1><p>1、生产者</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>				<span style=color:#080;font-style:italic>//创建一个连接工厂
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        ConnectionFactory factory <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> ConnectionFactory<span style=color:#666>();</span>
</span></span><span style=display:flex><span>        factory<span style=color:#666>.</span><span style=color:#b44>setHost</span><span style=color:#666>(</span><span style=color:#b44>&#34;59.110.161.137&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        factory<span style=color:#666>.</span><span style=color:#b44>setUsername</span><span style=color:#666>(</span><span style=color:#b44>&#34;lizi&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        factory<span style=color:#666>.</span><span style=color:#b44>setPassword</span><span style=color:#666>(</span><span style=color:#b44>&#34;lizi&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//channel 实现了自动 close 接口 自动关闭 不需要显示关闭
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        Connection connection <span style=color:#666>=</span> factory<span style=color:#666>.</span><span style=color:#b44>newConnection</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>        Channel channel <span style=color:#666>=</span> connection<span style=color:#666>.</span><span style=color:#b44>createChannel</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         * 生成一个队列
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         * 1.队列名称
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         * 2.队列里面的消息是否持久化 默认消息存储在内存中
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除 * 5.其他参数
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         */</span>
</span></span><span style=display:flex><span>        channel<span style=color:#666>.</span><span style=color:#b44>queueDeclare</span><span style=color:#666>(</span>QUEUE_NAME<span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        String message <span style=color:#666>=</span> <span style=color:#b44>&#34;hello world&#34;</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         * 发送一个消息
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         * 1.发送到那个交换机
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         * 2.路由的 key 是哪个
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         * 3.其他的参数信息
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         * 4.发送消息的消息体
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         */</span>
</span></span><span style=display:flex><span>        channel<span style=color:#666>.</span><span style=color:#b44>basicPublish</span><span style=color:#666>(</span><span style=color:#b44>&#34;&#34;</span><span style=color:#666>,</span> QUEUE_NAME<span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> message<span style=color:#666>.</span><span style=color:#b44>getBytes</span><span style=color:#666>());</span>
</span></span><span style=display:flex><span>        System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;消息发送完毕&#34;</span><span style=color:#666>);</span>
</span></span></code></pre></div><p>2、消费者</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>				ConnectionFactory factory <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> ConnectionFactory<span style=color:#666>();</span>
</span></span><span style=display:flex><span>        factory<span style=color:#666>.</span><span style=color:#b44>setHost</span><span style=color:#666>(</span><span style=color:#b44>&#34;59.110.161.137&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        factory<span style=color:#666>.</span><span style=color:#b44>setUsername</span><span style=color:#666>(</span><span style=color:#b44>&#34;lizi&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        factory<span style=color:#666>.</span><span style=color:#b44>setPassword</span><span style=color:#666>(</span><span style=color:#b44>&#34;lizi&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        Connection connection <span style=color:#666>=</span> factory<span style=color:#666>.</span><span style=color:#b44>newConnection</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>        Channel channel <span style=color:#666>=</span> connection<span style=color:#666>.</span><span style=color:#b44>createChannel</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;等待接收消息....&#34;</span><span style=color:#666>);</span> <span style=color:#080;font-style:italic>//推送的消息如何进行消费的接口回调
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        DeliverCallback deliverCallback<span style=color:#666>=(</span>consumerTag<span style=color:#666>,</span> delivery<span style=color:#666>)-&gt;{</span>
</span></span><span style=display:flex><span>            String message<span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> String<span style=color:#666>(</span>delivery<span style=color:#666>.</span><span style=color:#b44>getBody</span><span style=color:#666>());</span>
</span></span><span style=display:flex><span>            System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span>message<span style=color:#666>);</span>
</span></span><span style=display:flex><span>        <span style=color:#666>};</span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//取消消费的一个回调接口 如在消费的时候队列被删除掉了
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        CancelCallback cancelCallback<span style=color:#666>=(</span>consumerTag<span style=color:#666>)-&gt;{</span>
</span></span><span style=display:flex><span>        System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;消息消费被中断&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        <span style=color:#666>};</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         * 消费者消费消息
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         * 1.消费哪个队列
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答 *
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         * 3.消费者未成功消费的回调
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         * 4.消费者取消消费的回调
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         */</span>
</span></span><span style=display:flex><span>        channel<span style=color:#666>.</span><span style=color:#b44>basicConsume</span><span style=color:#666>(</span>QUEUE_NAME<span style=color:#666>,</span><span style=color:#a2f;font-weight:700>true</span><span style=color:#666>,</span>deliverCallback<span style=color:#666>,</span>cancelCallback<span style=color:#666>);</span>
</span></span></code></pre></div><h1 id=四工作队列原理简单模式工作模式>四、工作队列原理（简单模式、工作模式）</h1><p>工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。</p><p>相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。</p><p>在后台运行的工作进程将弹出任务并最终执行作业。</p><p>当有多个工作线程时，这些工作线程将一起处理这些任务。</p><p>生产者&mdash;&mdash;&mdash;队列&mdash;&mdash;&ndash;工作线程</p><p>​ 工作线程</p><p>​ 工作线程</p><p>注意事项：一个消息只能被处理一次，不可以处理多次</p><h3 id=1工具类>1）工具类</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>class</span> <span style=color:#00f>RabbitMqUtils</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//得到一个连接的 channel
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>static</span> Channel <span style=color:#00a000>getChannel</span><span style=color:#666>()</span> <span style=color:#a2f;font-weight:700>throws</span> Exception<span style=color:#666>{</span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//创建一个连接工厂
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        ConnectionFactory factory <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> ConnectionFactory<span style=color:#666>();</span>
</span></span><span style=display:flex><span>        factory<span style=color:#666>.</span><span style=color:#b44>setHost</span><span style=color:#666>(</span><span style=color:#b44>&#34;59.110.161.137&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        factory<span style=color:#666>.</span><span style=color:#b44>setUsername</span><span style=color:#666>(</span><span style=color:#b44>&#34;lizi&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        factory<span style=color:#666>.</span><span style=color:#b44>setPassword</span><span style=color:#666>(</span><span style=color:#b44>&#34;lizi&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        Connection connection <span style=color:#666>=</span> factory<span style=color:#666>.</span><span style=color:#b44>newConnection</span><span style=color:#666>();</span> 
</span></span><span style=display:flex><span>      	Channel channel <span style=color:#666>=</span> connection<span style=color:#666>.</span><span style=color:#b44>createChannel</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>return</span> channel<span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><h2 id=1工作队列案例>1、工作队列案例</h2><h3 id=1生产者-two>1）生产者 two</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>        Channel channel <span style=color:#666>=</span> RabbitMqUtils<span style=color:#666>.</span><span style=color:#b44>getChannel</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>        channel<span style=color:#666>.</span><span style=color:#b44>queueDeclare</span><span style=color:#666>(</span>QUEUE_NAME<span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//从控制台接收信息
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        Scanner scanner <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> Scanner<span style=color:#666>(</span>System<span style=color:#666>.</span><span style=color:#b44>in</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>while</span> <span style=color:#666>(</span>scanner<span style=color:#666>.</span><span style=color:#b44>hasNext</span><span style=color:#666>())</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>            String next <span style=color:#666>=</span> scanner<span style=color:#666>.</span><span style=color:#b44>next</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>            <span style=color:#080;font-style:italic>//1.发送到那个交换机
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>            <span style=color:#080;font-style:italic>//2.路由的 key 是哪个，队列
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>            <span style=color:#080;font-style:italic>//3.其他的参数信息
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>            <span style=color:#080;font-style:italic>//4.发送消息的消息体，二进制
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>            channel<span style=color:#666>.</span><span style=color:#b44>basicPublish</span><span style=color:#666>(</span><span style=color:#b44>&#34;&#34;</span><span style=color:#666>,</span> QUEUE_NAME<span style=color:#666>,</span><span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> next<span style=color:#666>.</span><span style=color:#b44>getBytes</span><span style=color:#666>());</span>
</span></span><span style=display:flex><span>            System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;发送消息完成&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        <span style=color:#666>}</span>
</span></span></code></pre></div><h3 id=2消费者>2）消费者</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>        Channel channel <span style=color:#666>=</span> RabbitMqUtils<span style=color:#666>.</span><span style=color:#b44>getChannel</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>        DeliverCallback deliverCallback <span style=color:#666>=</span> <span style=color:#666>(</span>consumerTag<span style=color:#666>,</span> message<span style=color:#666>)</span> <span style=color:#666>-&gt;</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>            System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;接收到的消息&#34;</span> <span style=color:#666>+</span> <span style=color:#a2f;font-weight:700>new</span> String<span style=color:#666>(</span>message<span style=color:#666>.</span><span style=color:#b44>getBody</span><span style=color:#666>()));</span>
</span></span><span style=display:flex><span>        <span style=color:#666>};</span>
</span></span><span style=display:flex><span>        CancelCallback cancelCallback <span style=color:#666>=</span> <span style=color:#666>(</span>consumerTag<span style=color:#666>)</span> <span style=color:#666>-&gt;</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>            System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span>consumerTag <span style=color:#666>+</span> <span style=color:#b44>&#34;消息者取消消费接口回调逻辑&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        <span style=color:#666>};</span>
</span></span><span style=display:flex><span>        System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;C2等待接收消息。。。。。。。&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        channel<span style=color:#666>.</span><span style=color:#b44>basicConsume</span><span style=color:#666>(</span>QUEUE_NAME<span style=color:#666>,</span><span style=color:#a2f;font-weight:700>true</span><span style=color:#666>,</span>deliverCallback<span style=color:#666>,</span>cancelCallback<span style=color:#666>);</span>
</span></span></code></pre></div><h2 id=2消息应答>2、消息应答</h2><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成 了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消 息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续 发送给该消费这的消息，因为它无法接收到。</p><p>为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是:消费者在接 收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</p><h3 id=1自动应答已接收到消息为准>1）自动应答（已接收到消息为准）</h3><p>消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权 衡,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢 失了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制， 当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终 使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并 以某种速率能够处理这些消息的情况下使用。</p><h3 id=2手动应答-three>2）手动应答 three</h3><p>Channel.basicAck ( 用于肯定确认 )</p><p>Channel.basicNack ( 用于否定确认 )</p><p>Channel.basicReject ( 用于否定确认 )</p><p>两个否定确认的区别是Channel.basicReject少一个参数 Multiple批处理</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>				Channel channel <span style=color:#666>=</span> RabbitMqUtils<span style=color:#666>.</span><span style=color:#b44>getChannel</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>        System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;C2等待接收消息处理时间较长&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        DeliverCallback deliverCallback <span style=color:#666>=</span> <span style=color:#666>(</span>consumerTag<span style=color:#666>,</span> message<span style=color:#666>)</span> <span style=color:#666>-&gt;</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>try</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>                TimeUnit<span style=color:#666>.</span><span style=color:#b44>SECONDS</span><span style=color:#666>.</span><span style=color:#b44>sleep</span><span style=color:#666>(</span>1<span style=color:#666>);</span>
</span></span><span style=display:flex><span>            <span style=color:#666>}</span> <span style=color:#a2f;font-weight:700>catch</span> <span style=color:#666>(</span>InterruptedException e<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>                e<span style=color:#666>.</span><span style=color:#b44>printStackTrace</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>            <span style=color:#666>}</span>
</span></span><span style=display:flex><span>            System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;接收到的消息 : &#34;</span> <span style=color:#666>+</span> <span style=color:#a2f;font-weight:700>new</span> String<span style=color:#666>(</span>message<span style=color:#666>.</span><span style=color:#b44>getBody</span><span style=color:#666>(),</span> <span style=color:#b44>&#34;UTF-8&#34;</span><span style=color:#666>));</span>
</span></span><span style=display:flex><span>            <span style=color:#080;font-style:italic>//手动应答
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>            channel<span style=color:#666>.</span><span style=color:#b44>basicAck</span><span style=color:#666>(</span>message<span style=color:#666>.</span><span style=color:#b44>getEnvelope</span><span style=color:#666>().</span><span style=color:#b44>getDeliveryTag</span><span style=color:#666>(),</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        <span style=color:#666>};</span>
</span></span><span style=display:flex><span>        <span style=color:#0b0;font-weight:700>boolean</span> autoAck <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>        channel<span style=color:#666>.</span><span style=color:#b44>basicConsume</span><span style=color:#666>(</span>ACK_QUEUE_NAME<span style=color:#666>,</span> autoAck<span style=color:#666>,</span> deliverCallback<span style=color:#666>,</span> <span style=color:#666>(</span>consumerTag <span style=color:#666>-&gt;</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>            System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span>consumerTag <span style=color:#666>+</span> <span style=color:#b44>&#34;消费者取消消费接口回调逻辑&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        <span style=color:#666>}));</span>
</span></span></code></pre></div><h3 id=3批量应答>3）批量应答</h3><p>公司里面不使用批量应答，防止多个数据丢失</p><p>Channel.basicAck ( deliveryTag, false )</p><h3 id=4消息自动重新入队>4）消息自动重新入队</h3><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息 未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者 可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确 保不会丢失任何消息。</p><h1 id=五持久化>五、持久化</h1><p>刚刚我们已经看到了如何处理任务不丢失的情况，但是如何保障当 RabbitMQ 服务停掉以后消 息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列 和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事:我们需要将队列和消息都标记为持久化。</p><h2 id=1队列如何实现持久化>1、队列如何实现持久化</h2><p>之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果 要队列实现持久化 需要在声明队列的时候把 durable 参数设置为持久化</p><p>但是需要注意的就是如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新
创建一个持久化的队列，不然就会出现错误</p><p>发消息的时候，生产者就需要通知这个消息需要持久化</p><h2 id=2消息实现持久化>2、消息实现持久化</h2><p>要想让消息实现持久化需要在消息生产者修改代码，MessageProperties.PERSISTENT_TEXT_PLAIN 添加这个属性。</p><p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是 这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果需要 更强有力的持久化策略，参考后边课件发布确认章节。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Channel channel <span style=color:#666>=</span> RabbitMqUtils<span style=color:#666>.</span><span style=color:#b44>getChannel</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>//这是声明队列的一系列参数，其具体的含义为：
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>//queueDeclare（名字，是否持久化，独占的queue， 不使用时是否自动删除，其他参数）；
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span style=color:#0b0;font-weight:700>boolean</span> durable <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>true</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>channel<span style=color:#666>.</span><span style=color:#b44>queueDeclare</span><span style=color:#666>(</span>ACK_QUEUE_NAME<span style=color:#666>,</span> durable<span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>//channel.queueDeclare(ACK_QUEUE_NAME, null, false, false, null);
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>//从控制台接收信息
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>Scanner scanner <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> Scanner<span style=color:#666>(</span>System<span style=color:#666>.</span><span style=color:#b44>in</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>while</span> <span style=color:#666>(</span>scanner<span style=color:#666>.</span><span style=color:#b44>hasNext</span><span style=color:#666>())</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>   String message <span style=color:#666>=</span> scanner<span style=color:#666>.</span><span style=color:#b44>next</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>//设置生产者发送消息为持久化消息
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>   channel<span style=color:#666>.</span><span style=color:#b44>basicPublish</span><span style=color:#666>(</span><span style=color:#b44>&#34;&#34;</span><span style=color:#666>,</span> ACK_QUEUE_NAME<span style=color:#666>,</span> MessageProperties<span style=color:#666>.</span><span style=color:#b44>PERSISTENT_TEXT_PLAIN</span><span style=color:#666>,</span> message<span style=color:#666>.</span><span style=color:#b44>getBytes</span><span style=color:#666>(</span><span style=color:#b44>&#34;UTF-8&#34;</span><span style=color:#666>));</span>
</span></span><span style=display:flex><span>   <span style=color:#080;font-style:italic>//channel.basicPublish(&#34;&#34;, ACK_QUEUE_NAME,null, message.getBytes(&#34;UTF-8&#34;));
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>   System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;发送消息完成&#34;</span> <span style=color:#666>+</span> message<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><h2 id=3不公平分发--能者多劳->3、不公平分发 ( 能者多劳 )</h2><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是 很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间 处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p><p>为了避免这种情况，我们可以设置参数 channel.basicQos(1)；</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>channel<span style=color:#666>.</span><span style=color:#b44>basicQos</span><span style=color:#666>(</span>1<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>boolean</span> autoAck <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>channel<span style=color:#666>.</span><span style=color:#b44>basicConsume</span><span style=color:#666>(</span>ACK_QUEUE_NAME<span style=color:#666>,</span> autoAck<span style=color:#666>,</span> deliverCallback<span style=color:#666>,</span> <span style=color:#666>(</span>consumerTag <span style=color:#666>-&gt;</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>     System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span>consumerTag <span style=color:#666>+</span> <span style=color:#b44>&#34;消费者取消消费接口回调逻辑&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}));</span>
</span></span></code></pre></div><p>意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个 任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加 新的 worker 或者改变其他存储任务的策略。</p><h2 id=4预取值--指定分配->4、预取值 ( 指定分配 )</h2><p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费 者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此 缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。<strong>该值定义通道上允许的未确认消息的最大数量</strong>。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为4，此时 RabbitMQ将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6这个消息刚刚被确认ACK，RabbitMQ将会感知这个情况到并再发送一条消息。消息应答和QoS预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理</strong>的消息的数量也会增加，从而增加了消费者的<strong>RAM</strong>消耗(随机存取存储器)应该小心使用具有无限预处理 的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为1是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#080;font-style:italic>//消费者里面设置
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>channel<span style=color:#666>.</span><span style=color:#b44>basicQos</span><span style=color:#666>(</span>2<span style=color:#666>);</span>
</span></span><span style=display:flex><span>channel<span style=color:#666>.</span><span style=color:#b44>basicQos</span><span style=color:#666>(</span>5<span style=color:#666>);</span>
</span></span></code></pre></div><h1 id=六发布确认发布确认模式>六、发布确认（发布确认模式）</h1><p>​ 发消息 rabbitmq</p><p>​ 生产者&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- 队列hello 磁盘上达到持久化目标</p><ul><li><p>要求队列持久化</p></li><li><p>设置要求队列中的消息也必须持久化</p></li><li><p>发布确认</p></li></ul><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的 消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队 列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传 给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p><p>confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信 道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调 方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消 息，生产者应用程序同样可以在回调方法中处理该 nack 消息。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#0b0;font-weight:700>boolean</span> durable <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>true</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>channel<span style=color:#666>.</span><span style=color:#b44>queueDeclare</span><span style=color:#666>(</span>ACK_QUEUE_NAME<span style=color:#666>,</span> durable<span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>//channel.queueDeclare(ACK_QUEUE_NAME, null, false, false, null);
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>//从控制台接收信息
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>Scanner scanner <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> Scanner<span style=color:#666>(</span>System<span style=color:#666>.</span><span style=color:#b44>in</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>while</span> <span style=color:#666>(</span>scanner<span style=color:#666>.</span><span style=color:#b44>hasNext</span><span style=color:#666>())</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>	String message <span style=color:#666>=</span> scanner<span style=color:#666>.</span><span style=color:#b44>next</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>	channel<span style=color:#666>.</span><span style=color:#b44>basicPublish</span><span style=color:#666>(</span><span style=color:#b44>&#34;&#34;</span><span style=color:#666>,</span> ACK_QUEUE_NAME<span style=color:#666>,</span> MessageProperties<span style=color:#666>.</span><span style=color:#b44>PERSISTENT_TEXT_PLAIN</span><span style=color:#666>,</span> message<span style=color:#666>.</span><span style=color:#b44>getBytes</span><span style=color:#666>(</span><span style=color:#b44>&#34;UTF-8&#34;</span><span style=color:#666>));</span>
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>//channel.basicPublish(&#34;&#34;, ACK_QUEUE_NAME,null, message.getBytes(&#34;UTF-8&#34;));
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>	System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;发送消息完成&#34;</span> <span style=color:#666>+</span> message<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><h2 id=1发布确认的策略>1、发布确认的策略</h2><h3 id=1开启发布确认的方法>1）开启发布确认的方法</h3><p>发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布 确认，都需要在 channel 上调用该方法</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>//开启发布确认
</span></span><span style=display:flex><span>channel.confirmSelect();
</span></span></code></pre></div><h3 id=2单个确认方法>2）单个确认方法</h3><p>这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它 被确认发布，后续的消息才能继续发布,waitForConfirmsOrDie(long)这个方法只有在消息被确认 的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p><p>这种确认方式有一个最大的缺点就是:发布速度特别的慢，因为如果没有确认发布的消息就会 阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某 些应用程序来说这可能已经足够了。</p><h3 id=3批量确认方法>3）批量确认方法</h3><p>上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地 提高吞吐量，当然这种方式的缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种 方案仍然是同步的，也一样阻塞消息的发布。</p><h3 id=4异步确认发布>4）异步确认发布</h3><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。</p><h3 id=5如何处理异步未确认消息>5）如何处理异步未确认消息</h3><p>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。</p><h3 id=6以上三种方式速度对比>6）以上三种方式速度对比</h3><p>①、单独发布消息
同步等待确认，简单，但吞吐量非常有限。</p><p>②、批量发布消息
批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条
消息出现了问题。</p><p>③、异步处理:
最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</p><h1 id=七交换机发布订阅模式>七、交换机（发布、订阅模式）</h1><p>生产者 &mdash;&mdash;交换机&mdash;&mdash;&ndash;队列&mdash;&mdash;-消费者</p><p>​ |_________队列&mdash;&mdash;&mdash;消费者 一个消息由交换机分发给两个队列，可以被消费两次</p><p>在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消 费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式 称为 ”发布/订阅”.</p><p><strong>five</strong></p><p>为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者</p><h2 id=1概念>1、概念</h2><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列</strong>。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。</p><p>相反，<strong>生产者只能将消息发送到交换机</strong>(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p><h3 id=1交换机的类型>1）交换机的类型</h3><p>接（direct）路由、主题（topic）、标题（headers）、扇出（fanout）</p><h3 id=2无名exchange>2）无名exchange</h3><p>在本教程的前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>channel<span style=color:#666>.</span><span style=color:#b44>basicPublish</span><span style=color:#666>(</span><span style=color:#b44>&#34;&#34;</span><span style=color:#666>,</span> <span style=color:#b44>&#34;hello&#34;</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> message<span style=color:#666>.</span><span style=color:#b44>getBytes</span><span style=color:#666>());</span>
</span></span></code></pre></div><p>第一个参数是交换机的名称。空字符串表示默认或无名称交换机:消息能路由发送到队列中其实 是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话</p><h2 id=2临时队列>2、临时队列</h2><p>String queueName = channel.queueDeclare().getQueue()</p><h2 id=3绑定bindings>3、绑定(bindings)</h2><h2 id=4fanout扇出交换机广播模式>4、Fanout（扇出交换机）广播模式</h2><p>1）简介</p><p>Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息<strong>广播</strong>到它知道的 所有队列中。系统中默认有些 exchange 类型</p><ul><li>与routingKey没有关系，会把消息发送到exchange所绑定的所有队列里面</li></ul><p>2）实战</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Channel channel <span style=color:#666>=</span> RabbitMqUtils<span style=color:#666>.</span><span style=color:#b44>getChannel</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>channel<span style=color:#666>.</span><span style=color:#b44>exchangeDeclare</span><span style=color:#666>(</span>EXCHANGE_NAME<span style=color:#666>,</span><span style=color:#b44>&#34;fanout&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>String queueName <span style=color:#666>=</span> channel<span style=color:#666>.</span><span style=color:#b44>queueDeclare</span><span style=color:#666>().</span><span style=color:#b44>getQueue</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>channel<span style=color:#666>.</span><span style=color:#b44>queueBind</span><span style=color:#666>(</span>queueName<span style=color:#666>,</span> EXCHANGE_NAME<span style=color:#666>,</span> <span style=color:#b44>&#34;&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;等待接收消息，把接收到的消息打在屏幕&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>DeliverCallback deliverCallback <span style=color:#666>=</span> <span style=color:#666>(</span>consumerTag<span style=color:#666>,</span> message<span style=color:#666>)</span> <span style=color:#666>-&gt;</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>   System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;1111111111111111控制台打印接收到的消息： &#34;</span> <span style=color:#666>+</span> <span style=color:#a2f;font-weight:700>new</span> String<span style=color:#666>(</span>message<span style=color:#666>.</span><span style=color:#b44>getBody</span><span style=color:#666>(),</span> <span style=color:#b44>&#34;UTF-8&#34;</span><span style=color:#666>));</span>
</span></span><span style=display:flex><span><span style=color:#666>};</span>
</span></span><span style=display:flex><span>channel<span style=color:#666>.</span><span style=color:#b44>basicConsume</span><span style=color:#666>(</span>queueName<span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>true</span><span style=color:#666>,</span> deliverCallback<span style=color:#666>,</span> consumerTag <span style=color:#666>-&gt;</span> <span style=color:#666>{});</span>
</span></span></code></pre></div><h2 id=5direct-exchange路由模式>5、Direct exchange（路由模式）</h2><p>1）回顾</p><p>在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本 节我们将向其中添加一些特别的功能-比方说我们只让某个消费者订阅发布的部分消息。例如我们只把 严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。</p><p>我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解: <strong>队列只对它绑定的交换机的消息感兴趣</strong>。绑定用参数:routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:</p><p>channel.queueBind(queueName, EXCHANGE_NAME, &ldquo;routingKey&rdquo;);</p><p><strong>绑定之后的 意义由其交换类型决定。</strong></p><p>2）介绍</p><p>上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希 望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。</p><p>3）多重绑定 <strong>six</strong></p><p>4）实战</p><h2 id=6topics主题模式>6、Topics（主题模式）</h2><p>1）类型</p><p>在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是 使用了 direct 交换机，从而有能实现有选择性地接收日志。</p><p>尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候 direct 就办不到了。这个时候 就只能使用 topic 类型</p><p>2）要求</p><p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它<strong>必须是一个单 词列表，以点号分隔开</strong>。这些单词可以是任意单词，比如说:&ldquo;stock.usd.nyse&rdquo;, &ldquo;nyse.vmw&rdquo;, &ldquo;quick.orange.rabbit&rdquo;.这种类型的。当然这个单词列表最多不能超过 255 个字节。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  在这个规则列表中<span>，</span>其中有两个替换符是大家需要注意的
</span></span><span style=display:flex><span>  <span style=color:#666>*(</span>星号<span style=color:#666>)</span>可以代替一个单词 
</span></span><span style=display:flex><span>  <span>#</span><span style=color:#666>(</span>井号<span style=color:#666>)</span>可以替代零个或多个单词
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#666>*.</span><span style=color:#b44>orange</span><span style=color:#666>.*</span>
</span></span><span style=display:flex><span><span style=color:#666>*.*.</span><span style=color:#b44>rabbit</span>
</span></span><span style=display:flex><span>lazy<span style=color:#666>.</span><span>#</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>quick<span style=color:#666>.</span><span style=color:#b44>orange</span><span style=color:#666>.</span><span style=color:#b44>rabbit</span>
</span></span><span style=display:flex><span>lazy<span style=color:#666>.</span><span style=color:#b44>orange</span><span style=color:#666>.</span><span style=color:#b44>elephant</span>
</span></span><span style=display:flex><span>quick<span style=color:#666>.</span><span style=color:#b44>orange</span><span style=color:#666>.</span><span style=color:#b44>fox</span>
</span></span><span style=display:flex><span>lazy<span style=color:#666>.</span><span style=color:#b44>brown</span><span style=color:#666>.</span><span style=color:#b44>fox</span>
</span></span><span style=display:flex><span>lazy<span style=color:#666>.</span><span style=color:#b44>pink</span><span style=color:#666>.</span><span style=color:#b44>rabbit</span>
</span></span><span style=display:flex><span>quick<span style=color:#666>.</span><span style=color:#b44>brown</span><span style=color:#666>.</span><span style=color:#b44>fox</span>
</span></span><span style=display:flex><span>quick<span style=color:#666>.</span><span style=color:#b44>orange</span><span style=color:#666>.</span><span style=color:#b44>male</span><span style=color:#666>.</span><span style=color:#b44>rabbit</span>
</span></span><span style=display:flex><span>lazy<span style=color:#666>.</span><span style=color:#b44>orange</span><span style=color:#666>.</span><span style=color:#b44>male</span><span style=color:#666>.</span><span style=color:#b44>rabbit</span>
</span></span></code></pre></div><p>3）实战 <strong>seven</strong></p><p>Q1&ndash;>绑定的是</p><p>中间带 orange 带 3 个单词的字符串(<em>.orange.</em>)</p><p>Q2&ndash;>绑定的是</p><p>最后一个单词是 rabbit 的 3 个单词(<em>.</em>.rabbit) 第一个单词是 lazy 的多个单词(lazy.#)</p><p>4）注意</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>当队列绑定关系是下列这种情况时需要引起注意<span>：</span>
</span></span><span style=display:flex><span>当一个队列绑定键是<span>#</span><span style=color:#666>,</span>那么这个队列将接收所有数据<span>，</span>就有点像 fanout 了 
</span></span><span style=display:flex><span>如果队列绑定键当中没有<span>#</span>和<span style=color:#666>*</span>出现<span>，</span>那么该队列绑定类型就是 direct 了
</span></span></code></pre></div><h1 id=八死信队列>八、死信队列</h1><h2 id=1死信的概念>1、死信的概念</h2><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的<strong>原因导致</strong> <strong>queue</strong> <strong>中的某些消息无法被消费</strong>，这样的消息如果没有 后续的处理，就变成了死信，有死信自然就有了死信队列。</p><p>应用场景:为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息 消费发生异常时，将消息投入死信队列中.还有比如说: 用户在商城下单成功并点击去支付后在指定时 间未支付时自动失效</p><h2 id=2死信的来源>2、死信的来源</h2><p>消息 TTL 过期 存活时间过期</p><p>队列达到最大长度(队列满了，无法再添加数据到 mq 中)</p><p>消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false.</p><h2 id=3死信实战>3、死信实战</h2><p>1）代码架构图</p><p>![image-20220806220702974](/Users/mac/Library/Application Support/typora-user-images/image-20220806220702974.png)</p><p>2）实战</p><p>设置消息TTL过期</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>class</span> <span style=color:#00f>Consumer01</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//普通交换机名称
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>private</span> <span style=color:#a2f;font-weight:700>static</span> <span style=color:#a2f;font-weight:700>final</span> String NORMAL_EXCHANGE <span style=color:#666>=</span> <span style=color:#b44>&#34;normal_exchange&#34;</span><span style=color:#666>;</span> <span style=color:#080;font-style:italic>//死信交换机名称
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>private</span> <span style=color:#a2f;font-weight:700>static</span> <span style=color:#a2f;font-weight:700>final</span> String DEAD_EXCHANGE <span style=color:#666>=</span> <span style=color:#b44>&#34;dead_exchange&#34;</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//普通队列
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>private</span> <span style=color:#a2f;font-weight:700>static</span> <span style=color:#a2f;font-weight:700>final</span> String NORMAL_QUEUE <span style=color:#666>=</span> <span style=color:#b44>&#34;normal_queue&#34;</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>private</span> <span style=color:#a2f;font-weight:700>static</span> <span style=color:#a2f;font-weight:700>final</span> String DEAD_QUEUE <span style=color:#666>=</span> <span style=color:#b44>&#34;dead_queue&#34;</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>static</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>main</span><span style=color:#666>(</span>String<span style=color:#666>[]</span> args<span style=color:#666>)</span> <span style=color:#a2f;font-weight:700>throws</span> Exception<span style=color:#666>{</span>
</span></span><span style=display:flex><span>        Channel channel <span style=color:#666>=</span> RabbitMqUtils<span style=color:#666>.</span><span style=color:#b44>getChannel</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        channel<span style=color:#666>.</span><span style=color:#b44>exchangeDeclare</span><span style=color:#666>(</span>NORMAL_EXCHANGE<span style=color:#666>,</span> BuiltinExchangeType<span style=color:#666>.</span><span style=color:#b44>DIRECT</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        channel<span style=color:#666>.</span><span style=color:#b44>exchangeDeclare</span><span style=color:#666>(</span>DEAD_EXCHANGE<span style=color:#666>,</span> BuiltinExchangeType<span style=color:#666>.</span><span style=color:#b44>DIRECT</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Map<span style=color:#666>&lt;</span>String<span style=color:#666>,</span> Object<span style=color:#666>&gt;</span> arguments <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> HashMap<span style=color:#666>&lt;&gt;();</span>
</span></span><span style=display:flex><span>        arguments<span style=color:#666>.</span><span style=color:#b44>put</span><span style=color:#666>(</span><span style=color:#b44>&#34;x-dead-letter-exchange&#34;</span><span style=color:#666>,</span> DEAD_EXCHANGE<span style=color:#666>);</span>
</span></span><span style=display:flex><span>        arguments<span style=color:#666>.</span><span style=color:#b44>put</span><span style=color:#666>(</span><span style=color:#b44>&#34;x-dead-letter-routing-key&#34;</span><span style=color:#666>,</span> <span style=color:#b44>&#34;lisi&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        arguments<span style=color:#666>.</span><span style=color:#b44>put</span><span style=color:#666>(</span><span style=color:#b44>&#34;x-message-ttl&#34;</span><span style=color:#666>,</span> 10000<span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        channel<span style=color:#666>.</span><span style=color:#b44>queueDeclare</span><span style=color:#666>(</span>NORMAL_QUEUE<span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> arguments<span style=color:#666>);</span>
</span></span><span style=display:flex><span>        channel<span style=color:#666>.</span><span style=color:#b44>queueDeclare</span><span style=color:#666>(</span>DEAD_QUEUE<span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        channel<span style=color:#666>.</span><span style=color:#b44>queueBind</span><span style=color:#666>(</span>NORMAL_QUEUE<span style=color:#666>,</span> NORMAL_EXCHANGE<span style=color:#666>,</span> <span style=color:#b44>&#34;zhangsan&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        channel<span style=color:#666>.</span><span style=color:#b44>queueBind</span><span style=color:#666>(</span>DEAD_QUEUE<span style=color:#666>,</span> DEAD_EXCHANGE<span style=color:#666>,</span> <span style=color:#b44>&#34;lisi&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;等待接收消息。。。&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        DeliverCallback deliverCallback <span style=color:#666>=</span> <span style=color:#666>(</span>consummerTag<span style=color:#666>,</span> message<span style=color:#666>)</span> <span style=color:#666>-&gt;</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>            System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;Consumer01接收的消息：&#34;</span> <span style=color:#666>+</span> <span style=color:#a2f;font-weight:700>new</span> String<span style=color:#666>(</span>message<span style=color:#666>.</span><span style=color:#b44>getBody</span><span style=color:#666>(),</span> <span style=color:#b44>&#34;UTF-8&#34;</span><span style=color:#666>));</span>
</span></span><span style=display:flex><span>        <span style=color:#666>};</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        channel<span style=color:#666>.</span><span style=color:#b44>basicConsume</span><span style=color:#666>(</span>NORMAL_QUEUE<span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>true</span><span style=color:#666>,</span> deliverCallback<span style=color:#666>,</span> consumerTag <span style=color:#666>-&gt;</span> <span style=color:#666>{});</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>队列达到最大长度</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>        Map<span style=color:#666>&lt;</span>String<span style=color:#666>,</span> Object<span style=color:#666>&gt;</span> arguments <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> HashMap<span style=color:#666>&lt;&gt;();</span>
</span></span><span style=display:flex><span>        arguments<span style=color:#666>.</span><span style=color:#b44>put</span><span style=color:#666>(</span><span style=color:#b44>&#34;x-dead-letter-exchange&#34;</span><span style=color:#666>,</span> DEAD_EXCHANGE<span style=color:#666>);</span>
</span></span><span style=display:flex><span>        arguments<span style=color:#666>.</span><span style=color:#b44>put</span><span style=color:#666>(</span><span style=color:#b44>&#34;x-dead-letter-routing-key&#34;</span><span style=color:#666>,</span> <span style=color:#b44>&#34;lisi&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//arguments.put(&#34;x-message-ttl&#34;, 10000);
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        arguments<span style=color:#666>.</span><span style=color:#b44>put</span><span style=color:#666>(</span><span style=color:#b44>&#34;x-max-length&#34;</span><span style=color:#666>,</span> 6<span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        channel<span style=color:#666>.</span><span style=color:#b44>queueDeclare</span><span style=color:#666>(</span>NORMAL_QUEUE<span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> arguments<span style=color:#666>);</span>
</span></span><span style=display:flex><span>        channel<span style=color:#666>.</span><span style=color:#b44>queueDeclare</span><span style=color:#666>(</span>DEAD_QUEUE<span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>);</span>
</span></span></code></pre></div></div><footer class=post-footer><div class=post-tags><a href=/tags/rabbitmq rel=tag title=RabbitMQ>#RabbitMQ#</a>
<a href=/tags/%e5%89%8a%e5%b3%b0 rel=tag title=削峰>#削峰#</a>
<a href=/tags/%e8%a7%a3%e8%80%a6 rel=tag title=解耦>#解耦#</a>
<a href=/tags/%e5%bc%82%e6%ad%a5 rel=tag title=异步>#异步#</a>
<a href=/tags/%e4%b8%ad%e9%97%b4%e4%bb%b6 rel=tag title=中间件>#中间件#</a></div><div class=addthis_inline_share_toolbox></div><div class=post-nav><div class=article-copyright><div class=article-copyright-img><img src=/img/qq_qrcode.png width=129px height=129px><div style=text-align:center>QQ扫一扫交流</div></div><div class=article-copyright-info><p><span>标题：</span>RabbitMQ（一）</p><p><span>链接：</span>https://zhang4014439175.github.io/post/rabbitmq%E4%B8%80/</p><p><span>作者：</span>凡梦星尘</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/3.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick='var qr=document.getElementById("QR");qr.style.display==="none"?qr.style.display="block":qr.style.display="none"'>
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://zhang4014439175.github.io/post/rabbitmq%E4%BA%8C/ rel=next title=RabbitMQ（二）><i class="fa fa-chevron-left"></i> RabbitMQ（二）</a></div><div class="post-nav-prev post-nav-item"><a href=https://zhang4014439175.github.io/post/docker%E5%9B%9B/ rel=prev title=docker（二）docker-compose>docker（二）docker-compose
<i class="fa fa-chevron-right"></i></a></div></div><div id=wcomments></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/img/avatar.png alt=凡梦星尘><p class=site-author-name itemprop=name>凡梦星尘</p><p class="site-description motion-element" itemprop=description>再平凡的人也有属于他自己的梦想!</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>29</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>33</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/elkan1788/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>
GitHub</a></span>
<span class=links-of-author-item><a href=https://www.zhihu.com/people/fan-meng-xing-chen-1 target=_blank title=知乎><i class="fa fa-fw fa-globe"></i>
知乎</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class=links-of-blogroll-title><i class="fa fa-fw fa-globe"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://nutzam.com/ title=Nutz target=_blank>Nutz</a></li><li class=links-of-blogroll-item><a href=https://jfinal.com/ title=JFinal target=_blank>JFinal</a></li><li class=links-of-blogroll-item><a href=http://wendal.net/ title=Wendal target=_blank>Wendal</a></li><li class=links-of-blogroll-item><a href=https://www.liaoxuefeng.com/ title=廖雪峰 target=_blank>廖雪峰</a></li></ul></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>
标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/java>Java
<sup>15</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/spring>Spring
<sup>7</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%A1%86%E6%9E%B6>框架
<sup>7</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/mysql>Mysql
<sup>5</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/sql>SQL
<sup>5</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/docker>Docker
<sup>4</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF>容器化技术
<sup>4</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/jvm>Jvm
<sup>2</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/mybatis>Mybatis
<sup>2</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/rabbitmq>Rabbitmq
<sup>2</sup></a></li></ul></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2010 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=copyright-author>热爱生活与梦想</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.96.0</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span class=site-uv><i class="fa fa-user"></i>
<span class=busuanzi-value id=busuanzi_value_site_uv></span></span>
<span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i>
<span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div><div class=license-info><span class=storage-info>Storage by
<a href=https://www.ucloud.cn/ style=font-weight:700 target=_blank>UCloud云存储</a></span>
<span class=separator-line>/</span>
<span class=license-num><a href=http://beian.miit.gov.cn target=_blank>粤ICP备18047355号</a></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i>
<span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//unpkg.com/jquery@2.1.4/dist/jquery.min.js></script>
<script type=text/javascript src=https://zhang4014439175.github.iojs/search.js></script>
<script type=text/javascript src=https://zhang4014439175.github.iojs/affix.js></script>
<script type=text/javascript>function detectIE(){var e=window.navigator.userAgent,t=e.indexOf("MSIE "),n=e.indexOf("Trident/"),s=e.indexOf("Edge/");return t>0||n>0||s>0?-1:1}function getCntViewHeight(){var t=$("#content").height(),e=$(window).height(),n=t>e?t-e:$(document).height()-e;return n}function getScrollbarWidth(){var e=$("<div />").addClass("scrollbar-measure").prependTo("body"),t=e[0],n=t.offsetWidth-t.clientWidth;return e.remove(),n}function registerBackTop(){var t=50,e=$(".back-to-top");$(window).on("scroll",function(){e.toggleClass("back-to-top-on",window.pageYOffset>t);var s=$(window).scrollTop(),o=getCntViewHeight(),i=s/o,n=Math.round(i*100),a=n>100?100:n;$("#scrollpercent>span").html(a)}),e.on("click",function(){$("html,body").animate({scrollTop:0,screenLeft:0},800)})}function initScrollSpy(){var e=".post-toc",s=$(e),t=".active-current";s.on("activate.bs.scrollspy",function(){var t=$(e+" .active").last();n(),t.addClass("active-current")}).on("clear.bs.scrollspy",n),$("body").scrollspy({target:e});function n(){$(e+" "+t).removeClass(t.substring(1))}}function initAffix(){var e=$(".header-inner").height(),t=parseInt($(".footer").outerHeight(!0),10),n=e+10;$(".sidebar-inner").affix({offset:{top:n,bottom:t}})}function initTOCDimension(){$(window).on("resize",function(){e&&clearTimeout(e),e=setTimeout(function(){var e=document.body.clientHeight-100;updateTOCHeight(e)},0)}),updateTOCHeight(document.body.clientHeight-100);var e,t=getScrollbarWidth();$(".post-toc").css("width","calc(100% + "+t+"px)")}function updateTOCHeight(e){e=e||"auto",$(".post-toc").css("max-height",e)}$(function(){var t=$(".header-inner").height()+10,n,s,e,o;$("#sidebar").css({'margin-top':t}).show(),n=parseInt($("#sidebar").css("margin-top")),s=parseInt($(".sidebar-inner").css("height")),e=n+s,o=$(".content-wrap").height(),o<e&&$(".content-wrap").css("min-height",e),$(".site-nav-toggle").on("click",function(){var e=$(".site-nav"),o=$(".toggle"),t="site-nav-on",i="toggle-close",n=e.hasClass(t),a=n?"slideUp":"slideDown",s=n?"removeClass":"addClass";e.stop()[a]("normal",function(){e[s](t),o[s](i)})}),registerBackTop(),initAffix(),initTOCDimension(),$(".sidebar-nav-toc").click(function(){$(this).addClass("sidebar-nav-active"),$(this).next().removeClass("sidebar-nav-active"),$("."+$(this).next().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)}),$(".sidebar-nav-overview").click(function(){$(this).addClass("sidebar-nav-active"),$(this).prev().removeClass("sidebar-nav-active"),$("."+$(this).prev().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)})})</script><script src=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.js></script>
<script type=text/javascript>$(function(){$(".post-body").viewer()})</script><script type=text/javascript>const locale={placeholder:"欢迎留下您的宝贵建议，请填写您的昵称和邮箱便于后续交流. ^_^"};$(function(){detectIE()>0?$.getScript(document.location.protocol+"//unpkg.com/@waline/client@1.6.0/dist/Waline.min.js",function(){new Waline({el:"#wcomments",visitor:!0,emoji:[],wordLimit:"200",uploadImage:!1,locale,requiredMeta:["nick","mail"],serverURL:"Your WalineSerURL",lang:"zh-cn"})}):$("#wcomments").html("抱歉，Waline插件不支持IE或Edge，建议使用Chrome浏览器。")})</script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=Your%20AddthisId"></script>
<script>(function(){var e=document.createElement("script"),t,n=window.location.protocol.split(":")[0];n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>